<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>SAMBA Developers Guide</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.77"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="SAMBA-DEVELOPERS-GUIDE"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="SAMBA-DEVELOPERS-GUIDE"
></A
>SAMBA Developers Guide</H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
></A
>SAMBA Team</H3
><HR></DIV
><HR><H1
><A
NAME="AEN8"
></A
>Abstract</H1
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Last Update</I
></SPAN
> : Mon Sep 30 15:23:53 CDT 2002</P
><P
>This book is a collection of documents that might be useful for 
people developing samba or those interested in doing so.
It's nothing more than a collection of documents written by samba developers about 
the internals of various parts of samba and the SMB protocol. It's still incomplete.
The most recent version of this document
can be found at <A
HREF="http://devel.samba.org/"
TARGET="_top"
>http://devel.samba.org/</A
>.
Please send updates to <A
HREF="mailto:jelmer@samba.org"
TARGET="_top"
>jelmer@samba.org</A
>.</P
><P
>This documentation is distributed under the GNU General Public License (GPL) 
version 2.  A copy of the license is included with the Samba source
distribution.  A copy can be found on-line at <A
HREF="http://www.fsf.org/licenses/gpl.txt"
TARGET="_top"
>http://www.fsf.org/licenses/gpl.txt</A
></P
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#NETBIOS"
>Definition of NetBIOS Protocol and Name Resolution Modes</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#AEN24"
>NETBIOS</A
></DT
><DT
>1.2. <A
HREF="#AEN35"
>BROADCAST NetBIOS</A
></DT
><DT
>1.3. <A
HREF="#AEN39"
>NBNS NetBIOS</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#ARCHITECTURE"
>Samba Architecture</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN54"
>Introduction</A
></DT
><DT
>2.2. <A
HREF="#AEN65"
>Multithreading and Samba</A
></DT
><DT
>2.3. <A
HREF="#AEN70"
>Threading smbd</A
></DT
><DT
>2.4. <A
HREF="#AEN86"
>Threading nmbd</A
></DT
><DT
>2.5. <A
HREF="#AEN92"
>nbmd Design</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#DEBUG"
>The samba DEBUG system</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN103"
>New Output Syntax</A
></DT
><DT
>3.2. <A
HREF="#AEN128"
>The DEBUG() Macro</A
></DT
><DT
>3.3. <A
HREF="#AEN151"
>The DEBUGADD() Macro</A
></DT
><DT
>3.4. <A
HREF="#AEN159"
>The DEBUGLVL() Macro</A
></DT
><DT
>3.5. <A
HREF="#AEN179"
>New Functions</A
></DT
><DD
><DL
><DT
>3.5.1. <A
HREF="#AEN181"
>dbgtext()</A
></DT
><DT
>3.5.2. <A
HREF="#AEN184"
>dbghdr()</A
></DT
><DT
>3.5.3. <A
HREF="#AEN188"
>format_debug_text()</A
></DT
></DL
></DD
></DL
></DD
><DT
>4. <A
HREF="#CODINGSUGGESTIONS"
>Coding Suggestions</A
></DT
><DT
>5. <A
HREF="#INTERNALS"
>Samba Internals</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#AEN284"
>Character Handling</A
></DT
><DT
>5.2. <A
HREF="#AEN288"
>The new functions</A
></DT
><DT
>5.3. <A
HREF="#AEN317"
>Macros in byteorder.h</A
></DT
><DD
><DL
><DT
>5.3.1. <A
HREF="#AEN320"
>CVAL(buf,pos)</A
></DT
><DT
>5.3.2. <A
HREF="#AEN323"
>PVAL(buf,pos)</A
></DT
><DT
>5.3.3. <A
HREF="#AEN326"
>SCVAL(buf,pos,val)</A
></DT
><DT
>5.3.4. <A
HREF="#AEN329"
>SVAL(buf,pos)</A
></DT
><DT
>5.3.5. <A
HREF="#AEN332"
>IVAL(buf,pos)</A
></DT
><DT
>5.3.6. <A
HREF="#AEN335"
>SVALS(buf,pos)</A
></DT
><DT
>5.3.7. <A
HREF="#AEN338"
>IVALS(buf,pos)</A
></DT
><DT
>5.3.8. <A
HREF="#AEN341"
>SSVAL(buf,pos,val)</A
></DT
><DT
>5.3.9. <A
HREF="#AEN344"
>SIVAL(buf,pos,val)</A
></DT
><DT
>5.3.10. <A
HREF="#AEN347"
>SSVALS(buf,pos,val)</A
></DT
><DT
>5.3.11. <A
HREF="#AEN350"
>SIVALS(buf,pos,val)</A
></DT
><DT
>5.3.12. <A
HREF="#AEN353"
>RSVAL(buf,pos)</A
></DT
><DT
>5.3.13. <A
HREF="#AEN356"
>RIVAL(buf,pos)</A
></DT
><DT
>5.3.14. <A
HREF="#AEN359"
>RSSVAL(buf,pos,val)</A
></DT
><DT
>5.3.15. <A
HREF="#AEN362"
>RSIVAL(buf,pos,val)</A
></DT
></DL
></DD
><DT
>5.4. <A
HREF="#AEN365"
>LAN Manager Samba API</A
></DT
><DD
><DL
><DT
>5.4.1. <A
HREF="#AEN371"
>Parameters</A
></DT
><DT
>5.4.2. <A
HREF="#AEN406"
>Return value</A
></DT
></DL
></DD
><DT
>5.5. <A
HREF="#AEN420"
>Code character table</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#PARSING"
>The smb.conf file</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#AEN451"
>Lexical Analysis</A
></DT
><DD
><DL
><DT
>6.1.1. <A
HREF="#AEN472"
>Handling of Whitespace</A
></DT
><DT
>6.1.2. <A
HREF="#AEN484"
>Handling of Line Continuation</A
></DT
><DT
>6.1.3. <A
HREF="#AEN495"
>Line Continuation Quirks</A
></DT
></DL
></DD
><DT
>6.2. <A
HREF="#AEN515"
>Syntax</A
></DT
><DD
><DL
><DT
>6.2.1. <A
HREF="#AEN530"
>About params.c</A
></DT
></DL
></DD
></DL
></DD
><DT
>7. <A
HREF="#UNIX-SMB"
>NetBIOS in a Unix World</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#AEN540"
>Introduction</A
></DT
><DT
>7.2. <A
HREF="#AEN544"
>Usernames</A
></DT
><DT
>7.3. <A
HREF="#AEN552"
>File Ownership</A
></DT
><DT
>7.4. <A
HREF="#AEN557"
>Passwords</A
></DT
><DT
>7.5. <A
HREF="#AEN563"
>Locking</A
></DT
><DT
>7.6. <A
HREF="#AEN571"
>Deny Modes</A
></DT
><DT
>7.7. <A
HREF="#AEN575"
>Trapdoor UIDs</A
></DT
><DT
>7.8. <A
HREF="#AEN579"
>Port numbers</A
></DT
><DT
>7.9. <A
HREF="#AEN584"
>Protocol Complexity</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#TRACING"
>Tracing samba system calls</A
></DT
><DT
>9. <A
HREF="#NTDOMAIN"
>NT Domain RPC's</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#AEN652"
>Introduction</A
></DT
><DD
><DL
><DT
>9.1.1. <A
HREF="#AEN688"
>Sources</A
></DT
><DT
>9.1.2. <A
HREF="#AEN695"
>Credits</A
></DT
></DL
></DD
><DT
>9.2. <A
HREF="#AEN702"
>Notes and Structures</A
></DT
><DD
><DL
><DT
>9.2.1. <A
HREF="#AEN704"
>Notes</A
></DT
><DT
>9.2.2. <A
HREF="#AEN717"
>Enumerations</A
></DT
><DT
>9.2.3. <A
HREF="#AEN775"
>Structures</A
></DT
></DL
></DD
><DT
>9.3. <A
HREF="#AEN1571"
>MSRPC over Transact Named Pipe</A
></DT
><DD
><DL
><DT
>9.3.1. <A
HREF="#AEN1574"
>MSRPC Pipes</A
></DT
><DT
>9.3.2. <A
HREF="#AEN1588"
>Header</A
></DT
><DT
>9.3.3. <A
HREF="#AEN1842"
>Tail</A
></DT
><DT
>9.3.4. <A
HREF="#AEN1854"
>RPC Bind / Bind Ack</A
></DT
><DT
>9.3.5. <A
HREF="#AEN1898"
>NTLSA Transact Named Pipe</A
></DT
><DT
>9.3.6. <A
HREF="#AEN1939"
>LSA Open Policy</A
></DT
><DT
>9.3.7. <A
HREF="#AEN1973"
>LSA Query Info Policy</A
></DT
><DT
>9.3.8. <A
HREF="#AEN2001"
>LSA Enumerate Trusted Domains</A
></DT
><DT
>9.3.9. <A
HREF="#AEN2025"
>LSA Open Secret</A
></DT
><DT
>9.3.10. <A
HREF="#AEN2054"
>LSA Close</A
></DT
><DT
>9.3.11. <A
HREF="#AEN2071"
>LSA Lookup SIDS</A
></DT
><DT
>9.3.12. <A
HREF="#AEN2130"
>LSA Lookup Names</A
></DT
></DL
></DD
><DT
>9.4. <A
HREF="#AEN2193"
>NETLOGON rpc Transact Named Pipe</A
></DT
><DD
><DL
><DT
>9.4.1. <A
HREF="#AEN2232"
>LSA Request Challenge</A
></DT
><DT
>9.4.2. <A
HREF="#AEN2267"
>LSA Authenticate 2</A
></DT
><DT
>9.4.3. <A
HREF="#AEN2306"
>LSA Server Password Set</A
></DT
><DT
>9.4.4. <A
HREF="#AEN2335"
>LSA SAM Logon</A
></DT
><DT
>9.4.5. <A
HREF="#AEN2359"
>LSA SAM Logoff</A
></DT
></DL
></DD
><DT
>9.5. <A
HREF="#AEN2382"
>\\MAILSLOT\NET\NTLOGON</A
></DT
><DD
><DL
><DT
>9.5.1. <A
HREF="#AEN2386"
>Query for PDC</A
></DT
><DT
>9.5.2. <A
HREF="#AEN2460"
>SAM Logon</A
></DT
></DL
></DD
><DT
>9.6. <A
HREF="#AEN2550"
>SRVSVC Transact Named Pipe</A
></DT
><DD
><DL
><DT
>9.6.1. <A
HREF="#AEN2562"
>Net Share Enum</A
></DT
><DT
>9.6.2. <A
HREF="#AEN2623"
>Net Server Get Info</A
></DT
></DL
></DD
><DT
>9.7. <A
HREF="#AEN2654"
>Cryptographic side of NT Domain Authentication</A
></DT
><DD
><DL
><DT
>9.7.1. <A
HREF="#AEN2656"
>Definitions</A
></DT
><DT
>9.7.2. <A
HREF="#AEN2699"
>Protocol</A
></DT
><DT
>9.7.3. <A
HREF="#AEN2709"
>Comments</A
></DT
></DL
></DD
><DT
>9.8. <A
HREF="#AEN2716"
>SIDs and RIDs</A
></DT
><DD
><DL
><DT
>9.8.1. <A
HREF="#AEN2724"
>Well-known SIDs</A
></DT
><DT
>9.8.2. <A
HREF="#AEN2812"
>Well-known RIDS</A
></DT
></DL
></DD
></DL
></DD
><DT
>10. <A
HREF="#PRINTING"
>Samba Printing Internals</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#AEN2896"
>Abstract</A
></DT
><DT
>10.2. <A
HREF="#AEN2899"
>Printing Interface to Various Back ends</A
></DT
><DT
>10.3. <A
HREF="#AEN2925"
>Print Queue TDB's</A
></DT
><DT
>10.4. <A
HREF="#AEN2959"
>ChangeID &#38; Client Caching of Printer Information</A
></DT
><DT
>10.5. <A
HREF="#AEN2962"
>Windows NT/2K Printer Change Notify</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#WINS"
>Samba WINS Internals</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#AEN3033"
>WINS Failover</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#SAM"
>The Upcoming SAM System</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#AEN3054"
>Security in the 'new SAM'</A
></DT
><DT
>12.2. <A
HREF="#AEN3071"
>Standalone from UNIX</A
></DT
><DT
>12.3. <A
HREF="#AEN3075"
>Handles and Races in the new SAM</A
></DT
><DT
>12.4. <A
HREF="#AEN3086"
>Layers</A
></DT
><DD
><DL
><DT
>12.4.1. <A
HREF="#AEN3088"
>Application</A
></DT
><DT
>12.4.2. <A
HREF="#AEN3091"
>SAM Interface</A
></DT
><DT
>12.4.3. <A
HREF="#AEN3095"
>SAM Modules</A
></DT
></DL
></DD
><DT
>12.5. <A
HREF="#AEN3098"
>SAM Modules</A
></DT
><DD
><DL
><DT
>12.5.1. <A
HREF="#AEN3100"
>Special Module: sam_passdb</A
></DT
><DT
>12.5.2. <A
HREF="#AEN3103"
>sam_ads</A
></DT
></DL
></DD
><DT
>12.6. <A
HREF="#AEN3107"
>Memory Management</A
></DT
><DT
>12.7. <A
HREF="#AEN3121"
>Testing</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#PWENCRYPT"
>LanMan and NT Password Encryption</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#AEN3147"
>Introduction</A
></DT
><DT
>13.2. <A
HREF="#AEN3151"
>How does it work?</A
></DT
><DT
>13.3. <A
HREF="#AEN3162"
><A
NAME="SMBPASSWDFILEFORMAT"
></A
>The smbpasswd file</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NETBIOS"
></A
>Chapter 1. Definition of NetBIOS Protocol and Name Resolution Modes</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN24"
></A
>1.1. NETBIOS</H2
><P
>NetBIOS runs over the following tranports: TCP/IP; NetBEUI and IPX/SPX.
Samba only uses NetBIOS over TCP/IP.  For details on the TCP/IP NetBIOS 
Session Service NetBIOS Datagram Service, and NetBIOS Names, see
rfc1001.txt and rfc1002.txt.</P
><P
> 
NetBEUI is a raw NetBIOS frame protocol implementation that allows NetBIOS
datagrams to be sent out over the 'wire' embedded within LLC frames.
NetBEUI is not required when using NetBIOS over TCP/IP protocols and it
is preferable NOT to install NetBEUI if it can be avoided.</P
><P
> 
IPX/SPX is also not required when using NetBIOS over TCP/IP, and it is
preferable NOT to install the IPX/SPX transport unless you are using Novell
servers.  At the very least, it is recommended that you do not install
'NetBIOS over IPX/SPX'.</P
><P
>[When installing Windows 95, you will find that NetBEUI and IPX/SPX are
installed as the default protocols.  This is because they are the simplest
to manage: no Windows 95 user-configuration is required].</P
><P
> 
NetBIOS applications (such as samba) offer their services (for example,
SMB file and print sharing) on a NetBIOS name.  They must claim this name
on the network before doing so.  The NetBIOS session service will then
accept connections on the application's behalf (on the NetBIOS name
claimed by the application).  A NetBIOS session between the application
and the client can then commence.</P
><P
> 
NetBIOS names consist of 15 characters plus a 'type' character.  This is
similar, in concept, to an IP address and a TCP port number, respectively.
A NetBIOS-aware application on a host will offer different services under
different NetBIOS name types, just as a host will offer different TCP/IP
services on different port numbers.</P
><P
> 
NetBIOS names must be claimed on a network, and must be defended.  The use
of NetBIOS names is most suitable on a single subnet; a Local Area Network
or a Wide Area Network.</P
><P
> 
NetBIOS names are either UNIQUE or GROUP.  Only one application can claim a
UNIQUE NetBIOS name on a network.</P
><P
>There are two kinds of NetBIOS Name resolution: Broadcast and Point-to-Point.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN35"
></A
>1.2. BROADCAST NetBIOS</H2
><P
> 
Clients can claim names, and therefore offer services on successfully claimed
names, on their broadcast-isolated subnet.  One way to get NetBIOS services
(such as browsing: see ftp.microsoft.com/drg/developr/CIFS/browdiff.txt; and
SMB file/print sharing: see cifs4.txt) working on a LAN or WAN is to make
your routers forward all broadcast packets from TCP/IP ports 137, 138 and 139.</P
><P
> 
This, however, is not recommended.  If you have a large LAN or WAN, you will
find that some of your hosts spend 95 percent of their time dealing with
broadcast traffic.  [If you have IPX/SPX on your LAN or WAN, you will find
that this is already happening: a packet analyzer will show, roughly
every twelve minutes, great swathes of broadcast traffic!].</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN39"
></A
>1.3. NBNS NetBIOS</H2
><P
>rfc1001.txt describes, amongst other things, the implementation and use
of, a 'NetBIOS Name Service'.  NT/AS offers 'Windows Internet Name Service'
which is fully rfc1001/2 compliant, but has had to take specific action
with certain NetBIOS names in order to make it useful.  (for example, it
deals with the registration of &#60;1c&#62; &#60;1d&#62; &#60;1e&#62; names all in different ways.
I recommend the reading of the Microsoft WINS Server Help files for full
details).</P
><P
> 
The use of a WINS server cuts down on broadcast network traffic for
NetBIOS name resolution.  It has the effect of pulling all the broadcast
isolated subnets together into a single NetBIOS scope, across your LAN
or WAN, while avoiding the use of TCP/IP broadcast packets.</P
><P
>When you have a WINS server on your LAN, WINS clients will be able to
contact the WINS server to resolve NetBIOS names.  Note that only those
WINS clients that have registered with the same WINS server will be
visible.  The WINS server _can_ have static NetBIOS entries added to its
database (usually for security reasons you might want to consider putting
your domain controllers or other important servers as static entries,
but you should not rely on this as your sole means of security), but for
the most part, NetBIOS names are registered dynamically.</P
><P
>This provides some confusion for lots of people, and is worth mentioning
here:  a Browse Server is NOT a WINS Server, even if these services are
implemented in the same application.  A Browse Server _needs_ a WINS server
because a Browse Server is a WINS client, which is _not_ the same thing].</P
><P
>Clients can claim names, and therefore offer services on successfully claimed
names, on their broadcast-isolated subnet.  One way to get NetBIOS services
(such as browsing: see ftp.microsoft.com/drg/developr/CIFS/browdiff.txt; and
SMB file/print sharing: see cifs6.txt) working on a LAN or WAN is to make
your routers forward all broadcast packets from TCP/IP ports 137, 138 and 139.
You will find, however, if you do this on a large LAN or a WAN, that your
network is completely swamped by NetBIOS and browsing packets, which is why
WINS was developed to minimise the necessity of broadcast traffic.</P
><P
> 
WINS Clients therefore claim names from the WINS server.  If the WINS
server allows them to register a name, the client's NetBIOS session service
can then offer services on this name.  Other WINS clients will then
contact the WINS server to resolve a NetBIOS name.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="ARCHITECTURE"
></A
>Chapter 2. Samba Architecture</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN54"
></A
>2.1. Introduction</H2
><P
>This document gives a general overview of how Samba works
internally. The Samba Team has tried to come up with a model which is
the best possible compromise between elegance, portability, security
and the constraints imposed by the very messy SMB and CIFS
protocol. </P
><P
>It also tries to answer some of the frequently asked questions such as:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>	Is Samba secure when running on Unix? The xyz platform?
	What about the root priveliges issue?</P
></LI
><LI
><P
>Pros and cons of multithreading in various parts of Samba</P
></LI
><LI
><P
>Why not have a separate process for name resolution, WINS, and browsing?</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN65"
></A
>2.2. Multithreading and Samba</H2
><P
>People sometimes tout threads as a uniformly good thing. They are very
nice in their place but are quite inappropriate for smbd. nmbd is
another matter, and multi-threading it would be very nice. </P
><P
>The short version is that smbd is not multithreaded, and alternative
servers that take this approach under Unix (such as Syntax, at the
time of writing) suffer tremendous performance penalties and are less
robust. nmbd is not threaded either, but this is because it is not
possible to do it while keeping code consistent and portable across 35
or more platforms. (This drawback also applies to threading smbd.)</P
><P
>The longer versions is that there are very good reasons for not making
smbd multi-threaded.  Multi-threading would actually make Samba much
slower, less scalable, less portable and much less robust. The fact
that we use a separate process for each connection is one of Samba's
biggest advantages.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN70"
></A
>2.3. Threading smbd</H2
><P
>A few problems that would arise from a threaded smbd are:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>	It's not only to create threads instead of processes, but you
	must care about all variables if they have to be thread specific
	(currently they would be global).</P
></LI
><LI
><P
>	if one thread dies (eg. a seg fault) then all threads die. We can
	immediately throw robustness out the window.</P
></LI
><LI
><P
>	many of the system calls we make are blocking. Non-blocking
	equivalents of many calls are either not available or are awkward (and
	slow) to use. So while we block in one thread all clients are
	waiting. Imagine if one share is a slow NFS filesystem and the others 
	are fast, we will end up slowing all clients to the speed of NFS.</P
></LI
><LI
><P
>	you can't run as a different uid in different threads. This means
	we would have to switch uid/gid on _every_ SMB packet. It would be
	horrendously slow.</P
></LI
><LI
><P
>	the per process file descriptor limit would mean that we could only
	support a limited number of clients.</P
></LI
><LI
><P
>	we couldn't use the system locking calls as the locking context of
	fcntl() is a process, not a thread.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN86"
></A
>2.4. Threading nmbd</H2
><P
>This would be ideal, but gets sunk by portability requirements.</P
><P
>Andrew tried to write a test threads library for nmbd that used only
ansi-C constructs (using setjmp and longjmp). Unfortunately some OSes
defeat this by restricting longjmp to calling addresses that are
shallower than the current address on the stack (apparently AIX does
this). This makes a truly portable threads library impossible. So to
support all our current platforms we would have to code nmbd both with
and without threads, and as the real aim of threads is to make the
code clearer we would not have gained anything. (it is a myth that
threads make things faster. threading is like recursion, it can make
things clear but the same thing can always be done faster by some
other method)</P
><P
>Chris tried to spec out a general design that would abstract threading
vs separate processes (vs other methods?) and make them accessible
through some general API. This doesn't work because of the data
sharing requirements of the protocol (packets in the future depending
on packets now, etc.) At least, the code would work but would be very
clumsy, and besides the fork() type model would never work on Unix. (Is there an OS that it would work on, for nmbd?)</P
><P
>A fork() is cheap, but not nearly cheap enough to do on every UDP
packet that arrives. Having a pool of processes is possible but is
nasty to program cleanly due to the enormous amount of shared data (in
complex structures) between the processes. We can't rely on each
platform having a shared memory system.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN92"
></A
>2.5. nbmd Design</H2
><P
>Originally Andrew used recursion to simulate a multi-threaded
environment, which use the stack enormously and made for really
confusing debugging sessions. Luke Leighton rewrote it to use a
queuing system that keeps state information on each packet.  The
first version used a single structure which was used by all the
pending states.  As the initialisation of this structure was
done by adding arguments, as the functionality developed, it got
pretty messy.  So, it was replaced with a higher-order function
and a pointer to a user-defined memory block.  This suddenly
made things much simpler: large numbers of functions could be
made static, and modularised.  This is the same principle as used
in NT's kernel, and achieves the same effect as threads, but in
a single process.</P
><P
>Then Jeremy rewrote nmbd. The packet data in nmbd isn't what's on the
wire. It's a nice format that is very amenable to processing but still
keeps the idea of a distinct packet. See "struct packet_struct" in
nameserv.h.  It has all the detail but none of the on-the-wire
mess. This makes it ideal for using in disk or memory-based databases
for browsing and WINS support. </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DEBUG"
></A
>Chapter 3. The samba DEBUG system</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN103"
></A
>3.1. New Output Syntax</H2
><P
>   The syntax of a debugging log file is represented as:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>  &gt;debugfile&lt; :== { &gt;debugmsg&lt; }

  &gt;debugmsg&lt;  :== &gt;debughdr&lt; '\n' &gt;debugtext&lt;

  &gt;debughdr&lt;  :== '[' TIME ',' LEVEL ']' FILE ':' [FUNCTION] '(' LINE ')'

  &gt;debugtext&lt; :== { &gt;debugline&lt; }

  &gt;debugline&lt; :== TEXT '\n'</PRE
></P
><P
>TEXT is a string of characters excluding the newline character.</P
><P
>LEVEL is the DEBUG level of the message (an integer in the range
		0..10).</P
><P
>TIME is a timestamp.</P
><P
>FILE is the name of the file from which the debug message was
generated.</P
><P
>FUNCTION is the function from which the debug message was generated.</P
><P
>LINE is the line number of the debug statement that generated the
message.</P
><P
>Basically, what that all means is:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>A debugging log file is made up of debug messages.</P
></LI
><LI
><P
>Each debug message is made up of a header and text. The header is
separated from the text by a newline.</P
></LI
><LI
><P
>The header begins with the timestamp and debug level of the
message enclosed in brackets. The filename, function, and line
number at which the message was generated follow. The filename is
terminated by a colon, and the function name is terminated by the
parenthesis which contain the line number. Depending upon the
compiler, the function name may be missing (it is generated by the
__FUNCTION__ macro, which is not universally implemented, dangit).</P
></LI
><LI
><P
>The message text is made up of zero or more lines, each terminated
by a newline.</P
></LI
></OL
><P
>Here's some example output:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>    [1998/08/03 12:55:25, 1] nmbd.c:(659)
      Netbios nameserver version 1.9.19-prealpha started.
      Copyright Andrew Tridgell 1994-1997
    [1998/08/03 12:55:25, 3] loadparm.c:(763)
      Initializing global parameters</PRE
></P
><P
>Note that in the above example the function names are not listed on
the header line. That's because the example above was generated on an
SGI Indy, and the SGI compiler doesn't support the __FUNCTION__ macro.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN128"
></A
>3.2. The DEBUG() Macro</H2
><P
>Use of the DEBUG() macro is unchanged. DEBUG() takes two parameters.
The first is the message level, the second is the body of a function
call to the Debug1() function.</P
><P
>That's confusing.</P
><P
>Here's an example which may help a bit. If you would write</P
><P
><PRE
CLASS="PROGRAMLISTING"
>printf( "This is a %s message.\n", "debug" );</PRE
></P
><P
>to send the output to stdout, then you would write</P
><P
><PRE
CLASS="PROGRAMLISTING"
>DEBUG( 0, ( "This is a %s message.\n", "debug" ) );</PRE
></P
><P
>to send the output to the debug file.  All of the normal printf()
formatting escapes work.</P
><P
>Note that in the above example the DEBUG message level is set to 0.
Messages at level 0 always print.  Basically, if the message level is
less than or equal to the global value DEBUGLEVEL, then the DEBUG
statement is processed.</P
><P
>The output of the above example would be something like:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>    [1998/07/30 16:00:51, 0] file.c:function(128)
      This is a debug message.</PRE
></P
><P
>Each call to DEBUG() creates a new header *unless* the output produced
by the previous call to DEBUG() did not end with a '\n'. Output to the
debug file is passed through a formatting buffer which is flushed
every time a newline is encountered. If the buffer is not empty when
DEBUG() is called, the new input is simply appended.</P
><P
>...but that's really just a Kludge. It was put in place because
DEBUG() has been used to write partial lines. Here's a simple (dumb)
example of the kind of thing I'm talking about:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>    DEBUG( 0, ("The test returned " ) );
    if( test() )
      DEBUG(0, ("True") );
    else
      DEBUG(0, ("False") );
    DEBUG(0, (".\n") );</PRE
></P
><P
>Without the format buffer, the output (assuming test() returned true)
would look like this:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>    [1998/07/30 16:00:51, 0] file.c:function(256)
      The test returned
    [1998/07/30 16:00:51, 0] file.c:function(258)
      True
    [1998/07/30 16:00:51, 0] file.c:function(261)
      .</PRE
></P
><P
>Which isn't much use. The format buffer kludge fixes this problem.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN151"
></A
>3.3. The DEBUGADD() Macro</H2
><P
>In addition to the kludgey solution to the broken line problem
described above, there is a clean solution. The DEBUGADD() macro never
generates a header. It will append new text to the current debug
message even if the format buffer is empty. The syntax of the
DEBUGADD() macro is the same as that of the DEBUG() macro.</P
><P
><PRE
CLASS="PROGRAMLISTING"
>    DEBUG( 0, ("This is the first line.\n" ) );
    DEBUGADD( 0, ("This is the second line.\nThis is the third line.\n" ) );</PRE
></P
><P
>Produces</P
><P
><PRE
CLASS="PROGRAMLISTING"
>    [1998/07/30 16:00:51, 0] file.c:function(512)
      This is the first line.
      This is the second line.
      This is the third line.</PRE
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN159"
></A
>3.4. The DEBUGLVL() Macro</H2
><P
>One of the problems with the DEBUG() macro was that DEBUG() lines
tended to get a bit long. Consider this example from
nmbd_sendannounce.c:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>  DEBUG(3,("send_local_master_announcement: type %x for name %s on subnet %s for workgroup %s\n",
            type, global_myname, subrec-&#62;subnet_name, work-&#62;work_group));</PRE
></P
><P
>One solution to this is to break it down using DEBUG() and DEBUGADD(),
as follows:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>  DEBUG( 3, ( "send_local_master_announcement: " ) );
  DEBUGADD( 3, ( "type %x for name %s ", type, global_myname ) );
  DEBUGADD( 3, ( "on subnet %s ", subrec-&#62;subnet_name ) );
  DEBUGADD( 3, ( "for workgroup %s\n", work-&#62;work_group ) );</PRE
></P
><P
>A similar, but arguably nicer approach is to use the DEBUGLVL() macro.
This macro returns True if the message level is less than or equal to
the global DEBUGLEVEL value, so:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>  if( DEBUGLVL( 3 ) )
    {
    dbgtext( "send_local_master_announcement: " );
    dbgtext( "type %x for name %s ", type, global_myname );
    dbgtext( "on subnet %s ", subrec-&#62;subnet_name );
    dbgtext( "for workgroup %s\n", work-&#62;work_group );
    }</PRE
></P
><P
>(The dbgtext() function is explained below.)</P
><P
>There are a few advantages to this scheme:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The test is performed only once.</P
></LI
><LI
><P
>You can allocate variables off of the stack that will only be used
within the DEBUGLVL() block.</P
></LI
><LI
><P
>Processing that is only relevant to debug output can be contained
within the DEBUGLVL() block.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN179"
></A
>3.5. New Functions</H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN181"
></A
>3.5.1. dbgtext()</H3
><P
>This function prints debug message text to the debug file (and
possibly to syslog) via the format buffer. The function uses a
variable argument list just like printf() or Debug1(). The
input is printed into a buffer using the vslprintf() function,
and then passed to format_debug_text().

If you use DEBUGLVL() you will probably print the body of the
message using dbgtext(). </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN184"
></A
>3.5.2. dbghdr()</H3
><P
>This is the function that writes a debug message header.
Headers are not processed via the format buffer. Also note that
if the format buffer is not empty, a call to dbghdr() will not
produce any output. See the comments in dbghdr() for more info.</P
><P
>It is not likely that this function will be called directly. It
is used by DEBUG() and DEBUGADD().</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN188"
></A
>3.5.3. format_debug_text()</H3
><P
>This is a static function in debug.c. It stores the output text
for the body of the message in a buffer until it encounters a
newline. When the newline character is found, the buffer is
written to the debug file via the Debug1() function, and the
buffer is reset. This allows us to add the indentation at the
beginning of each line of the message body, and also ensures
that the output is written a line at a time (which cleans up
syslog output).</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CODINGSUGGESTIONS"
></A
>Chapter 4. Coding Suggestions</H1
><P
>So you want to add code to Samba ...</P
><P
>One of the daunting tasks facing a programmer attempting to write code for
Samba is understanding the various coding conventions used by those most
active in the project.  These conventions were mostly unwritten and helped
improve either the portability, stability or consistency of the code. This
document will attempt to document a few of the more important coding
practices used at this time on the Samba project.  The coding practices are
expected to change slightly over time, and even to grow as more is learned
about obscure portability considerations.  Two existing documents
<TT
CLASS="FILENAME"
>samba/source/internals.doc</TT
> and 
<TT
CLASS="FILENAME"
>samba/source/architecture.doc</TT
> provide
additional information.</P
><P
>The loosely related question of coding style is very personal and this
document does not attempt to address that subject, except to say that I
have observed that eight character tabs seem to be preferred in Samba
source.  If you are interested in the topic of coding style, two oft-quoted
documents are:</P
><P
><A
HREF="http://lxr.linux.no/source/Documentation/CodingStyle"
TARGET="_top"
>http://lxr.linux.no/source/Documentation/CodingStyle</A
></P
><P
><A
HREF="http://www.fsf.org/prep/standards_toc.html"
TARGET="_top"
>http://www.fsf.org/prep/standards_toc.html</A
></P
><P
>But note that coding style in Samba varies due to the many different
programmers who have contributed.</P
><P
>Following are some considerations you should use when adding new code to
Samba.  First and foremost remember that:</P
><P
>Portability is a primary consideration in adding function, as is network
compatability with de facto, existing, real world CIFS/SMB implementations.
There are lots of platforms that Samba builds on so use caution when adding
a call to a library function that is not invoked in existing Samba code.
Also note that there are many quite different SMB/CIFS clients that Samba
tries to support, not all of which follow the SNIA CIFS Technical Reference
(or the earlier Microsoft reference documents or the X/Open book on the SMB
Standard) perfectly.</P
><P
>Here are some other suggestions:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>	use d_printf instead of printf for display text
	reason: enable auto-substitution of translated language text </P
></LI
><LI
><P
>	use SAFE_FREE instead of free
	reason: reduce traps due to null pointers</P
></LI
><LI
><P
>	don't use bzero use memset, or ZERO_STRUCT and ZERO_STRUCTP macros
	reason: not POSIX</P
></LI
><LI
><P
>	don't use strcpy and strlen (use safe_* equivalents)
	reason: to avoid traps due to buffer overruns</P
></LI
><LI
><P
>	don't use getopt_long, use popt functions instead
	reason: portability</P
></LI
><LI
><P
>	explicitly add const qualifiers on parm passing in functions where parm
	is input only (somewhat controversial but const can be #defined away)</P
></LI
><LI
><P
>	when passing a va_list as an arg, or assigning one to another
	please use the VA_COPY() macro
	reason: on some platforms, va_list is a struct that must be 
	initialized in each function...can SEGV if you don't.</P
></LI
><LI
><P
>	discourage use of threads
	reason: portability (also see architecture.doc)</P
></LI
><LI
><P
>	don't explicitly include new header files in C files - new h files 
	should be included by adding them once to includes.h
	reason: consistency</P
></LI
><LI
><P
>	don't explicitly extern functions (they are autogenerated by 
	"make proto" into proto.h)
	reason: consistency</P
></LI
><LI
><P
>	use endian safe macros when unpacking SMBs (see byteorder.h and
	internals.doc)
	reason: not everyone uses Intel</P
></LI
><LI
><P
>	Note Unicode implications of charset handling (see internals.doc).  See
	pull_*  and push_* and convert_string functions.
	reason: Internationalization</P
></LI
><LI
><P
>	Don't assume English only
	reason: See above</P
></LI
><LI
><P
>	Try to avoid using in/out parameters (functions that return data which
	overwrites input parameters)
	reason: Can cause stability problems</P
></LI
><LI
><P
>	Ensure copyright notices are correct, don't append Tridge's name to code
	that he didn't write.  If you did not write the code, make sure that it
	can coexist with the rest of the Samba GPLed code.</P
></LI
><LI
><P
>	Consider usage of DATA_BLOBs for length specified byte-data.
	reason: stability</P
></LI
><LI
><P
>	Take advantage of tdbs for database like function
	reason: consistency</P
></LI
><LI
><P
>	Don't access the SAM_ACCOUNT structure directly, they should be accessed
	via pdb_get...() and pdb_set...() functions.
	reason: stability, consistency</P
></LI
><LI
><P
>	Don't check a password directly against the passdb, always use the
	check_password() interface.
	reason: long term pluggability</P
></LI
><LI
><P
>	Try to use asprintf rather than pstrings and fstrings where possible</P
></LI
><LI
><P
>	Use normal C comments / * instead of C++ comments // like
	this.  Although the C++ comment format is part of the C99
	standard, some older vendor C compilers do not accept it.</P
></LI
><LI
><P
>	Try to write documentation for API functions and structures
	explaining the point of the code, the way it should be used, and
	any special conditions or results.  Mark these with a double-star
	comment start / ** so that they can be picked up by Doxygen, as in
	this file.</P
></LI
><LI
><P
>	Keep the scope narrow. This means making functions/variables
	static whenever possible. We don't want our namespace
	polluted. Each module should have a minimal number of externally
	visible functions or variables.</P
></LI
><LI
><P
>	Use function pointers to keep knowledge about particular pieces of
	code isolated in one place. We don't want a particular piece of
	functionality to be spread out across lots of places - that makes
	for fragile, hand to maintain code. Instead, design an interface
	and use tables containing function pointers to implement specific
	functionality. This is particularly important for command
	interpreters. </P
></LI
><LI
><P
>	Think carefully about what it will be like for someone else to add
	to and maintain your code. If it would be hard for someone else to
	maintain then do it another way. </P
></LI
></OL
><P
>The suggestions above are simply that, suggestions, but the information may
help in reducing the routine rework done on new code.  The preceeding list
is expected to change routinely as new support routines and macros are
added.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INTERNALS"
></A
>Chapter 5. Samba Internals</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN284"
></A
>5.1. Character Handling</H2
><P
>This section describes character set handling in Samba, as implemented in
Samba 3.0 and above</P
><P
>In the past Samba had very ad-hoc character set handling. Scattered
throughout the code were numerous calls which converted particular
strings to/from DOS codepages. The problem is that there was no way of
telling if a particular char* is in dos codepage or unix
codepage. This led to a nightmare of code that tried to cope with
particular cases without handlingt the general case.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN288"
></A
>5.2. The new functions</H2
><P
>The new system works like this:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>	all char* strings inside Samba are "unix" strings. These are
	multi-byte strings that are in the charset defined by the "unix
	charset" option in smb.conf. </P
></LI
><LI
><P
>	there is no single fixed character set for unix strings, but any
	character set that is used does need the following properties:
	</P
><P
></P
><OL
TYPE="a"
><LI
><P
>		must not contain NULLs except for termination
	</P
></LI
><LI
><P
>		must be 7-bit compatible with C strings, so that a constant
		string or character in C will be byte-for-byte identical to the
		equivalent string in the chosen character set. 
	</P
></LI
><LI
><P
>		when you uppercase or lowercase a string it does not become
		longer than the original string
	</P
></LI
><LI
><P
>		must be able to correctly hold all characters that your client
		will throw at it
	</P
></LI
></OL
><P
>	For example, UTF-8 is fine, and most multi-byte asian character sets
	are fine, but UCS2 could not be used for unix strings as they
	contain nulls.
	</P
></LI
><LI
><P
>	when you need to put a string into a buffer that will be sent on the
	wire, or you need a string in a character set format that is
	compatible with the clients character set then you need to use a
	pull_ or push_ function. The pull_ functions pull a string from a
	wire buffer into a (multi-byte) unix string. The push_ functions
	push a string out to a wire buffer. </P
></LI
><LI
><P
>	the two main pull_ and push_ functions you need to understand are
	pull_string and push_string. These functions take a base pointer
	that should point at the start of the SMB packet that the string is
	in. The functions will check the flags field in this packet to
	automatically determine if the packet is marked as a unicode packet,
	and they will choose whether to use unicode for this string based on
	that flag. You may also force this decision using the STR_UNICODE or
	STR_ASCII flags. For use in smbd/ and libsmb/ there are wrapper
	functions clistr_ and srvstr_ that call the pull_/push_ functions
	with the appropriate first argument.
	</P
><P
>	You may also call the pull_ascii/pull_ucs2 or push_ascii/push_ucs2
	functions if you know that a particular string is ascii or
	unicode. There are also a number of other convenience functions in
	charcnv.c that call the pull_/push_ functions with particularly
	common arguments, such as pull_ascii_pstring()
	</P
></LI
><LI
><P
>	The biggest thing to remember is that internal (unix) strings in Samba
	may now contain multi-byte characters. This means you cannot assume
	that characters are always 1 byte long. Often this means that you will
	have to convert strings to ucs2 and back again in order to do some
	(seemingly) simple task. For examples of how to do this see functions
	like strchr_m(). I know this is very slow, and we will eventually
	speed it up but right now we want this stuff correct not fast.</P
></LI
><LI
><P
>	all lp_ functions now return unix strings. The magic "DOS" flag on
	parameters is gone.</P
></LI
><LI
><P
>	all vfs functions take unix strings. Don't convert when passing to them</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN317"
></A
>5.3. Macros in byteorder.h</H2
><P
>This section describes the macros defined in byteorder.h.  These macros 
are used extensively in the Samba code.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN320"
></A
>5.3.1. CVAL(buf,pos)</H3
><P
>returns the byte at offset pos within buffer buf as an unsigned character.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN323"
></A
>5.3.2. PVAL(buf,pos)</H3
><P
>returns the value of CVAL(buf,pos) cast to type unsigned integer.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN326"
></A
>5.3.3. SCVAL(buf,pos,val)</H3
><P
>sets the byte at offset pos within buffer buf to value val.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN329"
></A
>5.3.4. SVAL(buf,pos)</H3
><P
>	returns the value of the unsigned short (16 bit) little-endian integer at 
	offset pos within buffer buf.  An integer of this type is sometimes
	refered to as "USHORT".</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN332"
></A
>5.3.5. IVAL(buf,pos)</H3
><P
>returns the value of the unsigned 32 bit little-endian integer at offset 
pos within buffer buf.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN335"
></A
>5.3.6. SVALS(buf,pos)</H3
><P
>returns the value of the signed short (16 bit) little-endian integer at 
offset pos within buffer buf.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN338"
></A
>5.3.7. IVALS(buf,pos)</H3
><P
>returns the value of the signed 32 bit little-endian integer at offset pos
within buffer buf.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN341"
></A
>5.3.8. SSVAL(buf,pos,val)</H3
><P
>sets the unsigned short (16 bit) little-endian integer at offset pos within 
buffer buf to value val.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN344"
></A
>5.3.9. SIVAL(buf,pos,val)</H3
><P
>sets the unsigned 32 bit little-endian integer at offset pos within buffer 
buf to the value val.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN347"
></A
>5.3.10. SSVALS(buf,pos,val)</H3
><P
>sets the short (16 bit) signed little-endian integer at offset pos within 
buffer buf to the value val.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN350"
></A
>5.3.11. SIVALS(buf,pos,val)</H3
><P
>sets the signed 32 bit little-endian integer at offset pos withing buffer
buf to the value val.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN353"
></A
>5.3.12. RSVAL(buf,pos)</H3
><P
>returns the value of the unsigned short (16 bit) big-endian integer at 
offset pos within buffer buf.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN356"
></A
>5.3.13. RIVAL(buf,pos)</H3
><P
>returns the value of the unsigned 32 bit big-endian integer at offset 
pos within buffer buf.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN359"
></A
>5.3.14. RSSVAL(buf,pos,val)</H3
><P
>sets the value of the unsigned short (16 bit) big-endian integer at 
offset pos within buffer buf to value val.
refered to as "USHORT".</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN362"
></A
>5.3.15. RSIVAL(buf,pos,val)</H3
><P
>sets the value of the unsigned 32 bit big-endian integer at offset 
pos within buffer buf to value val.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN365"
></A
>5.4. LAN Manager Samba API</H2
><P
>This section describes the functions need to make a LAN Manager RPC call.
This information had been obtained by examining the Samba code and the LAN
Manager 2.0 API documentation.  It should not be considered entirely
reliable.</P
><P
><PRE
CLASS="PROGRAMLISTING"
>call_api(int prcnt, int drcnt, int mprcnt, int mdrcnt, 
	char *param, char *data, char **rparam, char **rdata);</PRE
></P
><P
>This function is defined in client.c.  It uses an SMB transaction to call a
remote api.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN371"
></A
>5.4.1. Parameters</H3
><P
>The parameters are as follows:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>	prcnt: the number of bytes of parameters begin sent.</P
></LI
><LI
><P
>	drcnt:   the number of bytes of data begin sent.</P
></LI
><LI
><P
>	mprcnt:  the maximum number of bytes of parameters which should be returned</P
></LI
><LI
><P
>	mdrcnt:  the maximum number of bytes of data which should be returned</P
></LI
><LI
><P
>	param:   a pointer to the parameters to be sent.</P
></LI
><LI
><P
>	data:    a pointer to the data to be sent.</P
></LI
><LI
><P
>	rparam:  a pointer to a pointer which will be set to point to the returned
	paramters.  The caller of call_api() must deallocate this memory.</P
></LI
><LI
><P
>	rdata:   a pointer to a pointer which will be set to point to the returned 
	data.  The caller of call_api() must deallocate this memory.</P
></LI
></OL
><P
>These are the parameters which you ought to send, in the order of their
appearance in the parameter block:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>An unsigned 16 bit integer API number.  You should set this value with
SSVAL().  I do not know where these numbers are described.</P
></LI
><LI
><P
>An ASCIIZ string describing the parameters to the API function as defined
in the LAN Manager documentation.  The first parameter, which is the server
name, is ommited.  This string is based uppon the API function as described
in the manual, not the data which is actually passed.</P
></LI
><LI
><P
>An ASCIIZ string describing the data structure which ought to be returned.</P
></LI
><LI
><P
>Any parameters which appear in the function call, as defined in the LAN
Manager API documentation, after the "Server" and up to and including the
"uLevel" parameters.</P
></LI
><LI
><P
>An unsigned 16 bit integer which gives the size in bytes of the buffer we
will use to receive the returned array of data structures.  Presumably this
should be the same as mdrcnt.  This value should be set with SSVAL().</P
></LI
><LI
><P
>An ASCIIZ string describing substructures which should be returned.  If no 
substructures apply, this string is of zero length.</P
></LI
></OL
><P
>The code in client.c always calls call_api() with no data.  It is unclear
when a non-zero length data buffer would be sent.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN406"
></A
>5.4.2. Return value</H3
><P
>The returned parameters (pointed to by rparam), in their order of appearance
are:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>An unsigned 16 bit integer which contains the API function's return code. 
This value should be read with SVAL().</P
></LI
><LI
><P
>An adjustment which tells the amount by which pointers in the returned
data should be adjusted.  This value should be read with SVAL().  Basically, 
the address of the start of the returned data buffer should have the returned
pointer value added to it and then have this value subtracted from it in
order to obtain the currect offset into the returned data buffer.</P
></LI
><LI
><P
>A count of the number of elements in the array of structures returned. 
It is also possible that this may sometimes be the number of bytes returned.</P
></LI
></OL
><P
>When call_api() returns, rparam points to the returned parameters.  The
first if these is the result code.  It will be zero if the API call
suceeded.  This value by be read with "SVAL(rparam,0)".</P
><P
>The second parameter may be read as "SVAL(rparam,2)".  It is a 16 bit offset
which indicates what the base address of the returned data buffer was when
it was built on the server.  It should be used to correct pointer before
use.</P
><P
>The returned data buffer contains the array of returned data structures. 
Note that all pointers must be adjusted before use.  The function
fix_char_ptr() in client.c can be used for this purpose.</P
><P
>The third parameter (which may be read as "SVAL(rparam,4)") has something to
do with indicating the amount of data returned or possibly the amount of
data which can be returned if enough buffer space is allowed.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN420"
></A
>5.5. Code character table</H2
><P
>Certain data structures are described by means of ASCIIz strings containing
code characters.  These are the code characters:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>W	a type byte little-endian unsigned integer</P
></LI
><LI
><P
>N	a count of substructures which follow</P
></LI
><LI
><P
>D	a four byte little-endian unsigned integer</P
></LI
><LI
><P
>B	a byte (with optional count expressed as trailing ASCII digits)</P
></LI
><LI
><P
>z	a four byte offset to a NULL terminated string</P
></LI
><LI
><P
>l	a four byte offset to non-string user data</P
></LI
><LI
><P
>b	an offset to data (with count expressed as trailing ASCII digits)</P
></LI
><LI
><P
>r	pointer to returned data buffer???</P
></LI
><LI
><P
>L	length in bytes of returned data buffer???</P
></LI
><LI
><P
>h	number of bytes of information available???</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PARSING"
></A
>Chapter 6. The smb.conf file</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN451"
></A
>6.1. Lexical Analysis</H2
><P
>Basically, the file is processed on a line by line basis.  There are
four types of lines that are recognized by the lexical analyzer
(params.c):</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Blank lines - Lines containing only whitespace.</P
></LI
><LI
><P
>Comment lines - Lines beginning with either a semi-colon or a
pound sign (';' or '#').</P
></LI
><LI
><P
>Section header lines - Lines beginning with an open square bracket ('[').</P
></LI
><LI
><P
>Parameter lines - Lines beginning with any other character.
(The default line type.)</P
></LI
></OL
><P
>The first two are handled exclusively by the lexical analyzer, which
ignores them.  The latter two line types are scanned for</P
><P
></P
><OL
TYPE="1"
><LI
><P
>  - Section names</P
></LI
><LI
><P
>  - Parameter names</P
></LI
><LI
><P
>  - Parameter values</P
></LI
></OL
><P
>These are the only tokens passed to the parameter loader
(loadparm.c).  Parameter names and values are divided from one
another by an equal sign: '='.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN472"
></A
>6.1.1. Handling of Whitespace</H3
><P
>Whitespace is defined as all characters recognized by the isspace()
function (see ctype(3C)) except for the newline character ('\n')
The newline is excluded because it identifies the end of the line.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The lexical analyzer scans past white space at the beginning of a line.</P
></LI
><LI
><P
>Section and parameter names may contain internal white space.  All
whitespace within a name is compressed to a single space character. </P
></LI
><LI
><P
>Internal whitespace within a parameter value is kept verbatim with 
the exception of carriage return characters ('\r'), all of which
are removed.</P
></LI
><LI
><P
>Leading and trailing whitespace is removed from names and values.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN484"
></A
>6.1.2. Handling of Line Continuation</H3
><P
>Long section header and parameter lines may be extended across
multiple lines by use of the backslash character ('\\').  Line
continuation is ignored for blank and comment lines.</P
><P
>If the last (non-whitespace) character within a section header or on
a parameter line is a backslash, then the next line will be
(logically) concatonated with the current line by the lexical
analyzer.  For example:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>	param name = parameter value string \
	with line continuation.</PRE
></P
><P
>Would be read as</P
><P
><PRE
CLASS="PROGRAMLISTING"
>    param name = parameter value string     with line continuation.</PRE
></P
><P
>Note that there are five spaces following the word 'string',
representing the one space between 'string' and '\\' in the top
line, plus the four preceeding the word 'with' in the second line.
(Yes, I'm counting the indentation.)</P
><P
>Line continuation characters are ignored on blank lines and at the end
of comments.  They are *only* recognized within section and parameter
lines.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN495"
></A
>6.1.3. Line Continuation Quirks</H3
><P
>Note the following example:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>	param name = parameter value string \
    \
    with line continuation.</PRE
></P
><P
>The middle line is *not* parsed as a blank line because it is first
concatonated with the top line.  The result is</P
><P
><PRE
CLASS="PROGRAMLISTING"
>param name = parameter value string         with line continuation.</PRE
></P
><P
>The same is true for comment lines.</P
><P
><PRE
CLASS="PROGRAMLISTING"
>	param name = parameter value string \
	; comment \
    with a comment.</PRE
></P
><P
>This becomes:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>param name = parameter value string     ; comment     with a comment.</PRE
></P
><P
>On a section header line, the closing bracket (']') is considered a
terminating character, and the rest of the line is ignored.  The lines</P
><P
><PRE
CLASS="PROGRAMLISTING"
>	[ section   name ] garbage \
    param  name  = value</PRE
></P
><P
>are read as</P
><P
><PRE
CLASS="PROGRAMLISTING"
>	[section name]
    param name = value</PRE
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN515"
></A
>6.2. Syntax</H2
><P
>The syntax of the smb.conf file is as follows:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>  &lt;file&gt;            :==  { &lt;section&gt; } EOF
  &lt;section&gt;         :==  &lt;section header&gt; { &lt;parameter line&gt; }
  &lt;section header&gt;  :==  '[' NAME ']'
  &lt;parameter line&gt;  :==  NAME '=' VALUE NL</PRE
></P
><P
>Basically, this means that</P
><P
></P
><OL
TYPE="1"
><LI
><P
>	a file is made up of zero or more sections, and is terminated by
	an EOF (we knew that).</P
></LI
><LI
><P
>	A section is made up of a section header followed by zero or more
	parameter lines.</P
></LI
><LI
><P
>	A section header is identified by an opening bracket and
	terminated by the closing bracket.  The enclosed NAME identifies
	the section.</P
></LI
><LI
><P
>	A parameter line is divided into a NAME and a VALUE.  The *first*
	equal sign on the line separates the NAME from the VALUE.  The
	VALUE is terminated by a newline character (NL = '\n').</P
></LI
></OL
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN530"
></A
>6.2.1. About params.c</H3
><P
>The parsing of the config file is a bit unusual if you are used to
lex, yacc, bison, etc.  Both lexical analysis (scanning) and parsing
are performed by params.c.  Values are loaded via callbacks to
loadparm.c.</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="UNIX-SMB"
></A
>Chapter 7. NetBIOS in a Unix World</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN540"
></A
>7.1. Introduction</H2
><P
>This is a short document that describes some of the issues that
confront a SMB implementation on unix, and how Samba copes with
them. They may help people who are looking at unix&#60;-&#62;PC
interoperability.</P
><P
>It was written to help out a person who was writing a paper on unix to
PC connectivity.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN544"
></A
>7.2. Usernames</H2
><P
>The SMB protocol has only a loose username concept. Early SMB
protocols (such as CORE and COREPLUS) have no username concept at
all. Even in later protocols clients often attempt operations
(particularly printer operations) without first validating a username
on the server.</P
><P
>Unix security is based around username/password pairs. A unix box
should not allow clients to do any substantive operation without some
sort of validation. </P
><P
>The problem mostly manifests itself when the unix server is in "share
level" security mode. This is the default mode as the alternative
"user level" security mode usually forces a client to connect to the
server as the same user for each connected share, which is
inconvenient in many sites.</P
><P
>In "share level" security the client normally gives a username in the
"session setup" protocol, but does not supply an accompanying
password. The client then connects to resources using the "tree
connect" protocol, and supplies a password. The problem is that the
user on the PC types the username and the password in different
contexts, unaware that they need to go together to give access to the
server. The username is normally the one the user typed in when they
"logged onto" the PC (this assumes Windows for Workgroups). The
password is the one they chose when connecting to the disk or printer.</P
><P
>The user often chooses a totally different username for their login as
for the drive connection. Often they also want to access different
drives as different usernames. The unix server needs some way of
divining the correct username to combine with each password.</P
><P
>Samba tries to avoid this problem using several methods. These succeed
in the vast majority of cases. The methods include username maps, the
service%user syntax, the saving of session setup usernames for later
validation and the derivation of the username from the service name
(either directly or via the user= option).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN552"
></A
>7.3. File Ownership</H2
><P
>The commonly used SMB protocols have no way of saying "you can't do
that because you don't own the file". They have, in fact, no concept
of file ownership at all.</P
><P
>This brings up all sorts of interesting problems. For example, when
you copy a file to a unix drive, and the file is world writeable but
owned by another user the file will transfer correctly but will
receive the wrong date. This is because the utime() call under unix
only succeeds for the owner of the file, or root, even if the file is
world writeable. For security reasons Samba does all file operations
as the validated user, not root, so the utime() fails. This can stuff
up shared development diectories as programs like "make" will not get
file time comparisons right.</P
><P
>There are several possible solutions to this problem, including
username mapping, and forcing a specific username for particular
shares.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN557"
></A
>7.4. Passwords</H2
><P
>Many SMB clients uppercase passwords before sending them. I have no
idea why they do this. Interestingly WfWg uppercases the password only
if the server is running a protocol greater than COREPLUS, so
obviously it isn't just the data entry routines that are to blame.</P
><P
>Unix passwords are case sensitive. So if users use mixed case
passwords they are in trouble.</P
><P
>Samba can try to cope with this by either using the "password level"
option which causes Samba to try the offered password with up to the
specified number of case changes, or by using the "password server"
option which allows Samba to do its validation via another machine
(typically a WinNT server).</P
><P
>Samba supports the password encryption method used by SMB
clients. Note that the use of password encryption in Microsoft
networking leads to password hashes that are "plain text equivalent".
This means that it is *VERY* important to ensure that the Samba
smbpasswd file containing these password hashes is only readable
by the root user. See the documentation ENCRYPTION.txt for more
details.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN563"
></A
>7.5. Locking</H2
><P
>Since samba 2.2, samba supports other types of locking as well. This 
section is outdated.</P
><P
>The locking calls available under a DOS/Windows environment are much
richer than those available in unix. This means a unix server (like
Samba) choosing to use the standard fcntl() based unix locking calls
to implement SMB locking has to improvise a bit.</P
><P
>One major problem is that dos locks can be in a 32 bit (unsigned)
range. Unix locking calls are 32 bits, but are signed, giving only a 31
bit range. Unfortunately OLE2 clients use the top bit to select a
locking range used for OLE semaphores.</P
><P
>To work around this problem Samba compresses the 32 bit range into 31
bits by appropriate bit shifting. This seems to work but is not
ideal. In a future version a separate SMB lockd may be added to cope
with the problem.</P
><P
>It also doesn't help that many unix lockd daemons are very buggy and
crash at the slightest provocation. They normally go mostly unused in
a unix environment because few unix programs use byte range
locking. The stress of huge numbers of lock requests from dos/windows
clients can kill the daemon on some systems.</P
><P
>The second major problem is the "opportunistic locking" requested by
some clients. If a client requests opportunistic locking then it is
asking the server to notify it if anyone else tries to do something on
the same file, at which time the client will say if it is willing to
give up its lock. Unix has no simple way of implementing
opportunistic locking, and currently Samba has no support for it.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN571"
></A
>7.6. Deny Modes</H2
><P
>When a SMB client opens a file it asks for a particular "deny mode" to
be placed on the file. These modes (DENY_NONE, DENY_READ, DENY_WRITE,
DENY_ALL, DENY_FCB and DENY_DOS) specify what actions should be
allowed by anyone else who tries to use the file at the same time. If
DENY_READ is placed on the file, for example, then any attempt to open
the file for reading should fail.</P
><P
>Unix has no equivalent notion. To implement this Samba uses either lock
files based on the files inode and placed in a separate lock
directory or a shared memory implementation. The lock file method 
is clumsy and consumes processing and file resources,
the shared memory implementation is vastly prefered and is turned on
by default for those systems that support it.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN575"
></A
>7.7. Trapdoor UIDs</H2
><P
>A SMB session can run with several uids on the one socket. This
happens when a user connects to two shares with different
usernames. To cope with this the unix server needs to switch uids
within the one process. On some unixes (such as SCO) this is not
possible. This means that on those unixes the client is restricted to
a single uid.</P
><P
>Note that you can also get the "trapdoor uid" message for other
reasons. Please see the FAQ for details.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN579"
></A
>7.8. Port numbers</H2
><P
>There is a convention that clients on sockets use high "unprivilaged"
port numbers (&#62;1000) and connect to servers on low "privilaged" port
numbers. This is enforced in Unix as non-root users can't open a
socket for listening on port numbers less than 1000.</P
><P
>Most PC based SMB clients (such as WfWg and WinNT) don't follow this
convention completely. The main culprit is the netbios nameserving on
udp port 137. Name query requests come from a source port of 137. This
is a problem when you combine it with the common firewalling technique
of not allowing incoming packets on low port numbers. This means that
these clients can't query a netbios nameserver on the other side of a
low port based firewall.</P
><P
>The problem is more severe with netbios node status queries. I've
found that WfWg, Win95 and WinNT3.5 all respond to netbios node status
queries on port 137 no matter what the source port was in the
request. This works between machines that are both using port 137, but
it means it's not possible for a unix user to do a node status request
to any of these OSes unless they are running as root. The answer comes
back, but it goes to port 137 which the unix user can't listen
on. Interestingly WinNT3.1 got this right - it sends node status
responses back to the source port in the request.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN584"
></A
>7.9. Protocol Complexity</H2
><P
>There are many "protocol levels" in the SMB protocol. It seems that
each time new functionality was added to a Microsoft operating system,
they added the equivalent functions in a new protocol level of the SMB
protocol to "externalise" the new capabilities.</P
><P
>This means the protocol is very "rich", offering many ways of doing
each file operation. This means SMB servers need to be complex and
large. It also means it is very difficult to make them bug free. It is
not just Samba that suffers from this problem, other servers such as
WinNT don't support every variation of every call and it has almost
certainly been a headache for MS developers to support the myriad of
SMB calls that are available.</P
><P
>There are about 65 "top level" operations in the SMB protocol (things
like SMBread and SMBwrite). Some of these include hundreds of
sub-functions (SMBtrans has at least 120 sub-functions, like
DosPrintQAdd and NetSessionEnum). All of them take several options
that can change the way they work. Many take dozens of possible
"information levels" that change the structures that need to be
returned. Samba supports all but 2 of the "top level" functions. It
supports only 8 (so far) of the SMBtrans sub-functions. Even NT
doesn't support them all.</P
><P
>Samba currently supports up to the "NT LM 0.12" protocol, which is the
one preferred by Win95 and WinNT3.5. Luckily this protocol level has a
"capabilities" field which specifies which super-duper new-fangled
options the server suports. This helps to make the implementation of
this protocol level much easier.</P
><P
>There is also a problem with the SMB specications. SMB is a X/Open
spec, but the X/Open book is far from ideal, and fails to cover many
important issues, leaving much to the imagination. Microsoft recently
renamed the SMB protocol CIFS (Common Internet File System) and have 
published new specifications. These are far superior to the old 
X/Open documents but there are still undocumented calls and features. 
This specification is actively being worked on by a CIFS developers 
mailing list hosted by Microsft.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TRACING"
></A
>Chapter 8. Tracing samba system calls</H1
><P
>This file describes how to do a system call trace on Samba to work out
what its doing wrong. This is not for the faint of heart, but if you
are reading this then you are probably desperate.</P
><P
>Actually its not as bad as the the above makes it sound, just don't
expect the output to be very pretty :-)</P
><P
>Ok, down to business. One of the big advantages of unix systems is
that they nearly all come with a system trace utility that allows you
to monitor all system calls that a program is making. This is
extremely using for debugging and also helps when trying to work out
why something is slower than you expect. You can use system tracing
without any special compilation options. </P
><P
>The system trace utility is called different things on different
systems. On Linux systems its called strace. Under SunOS 4 its called
trace. Under SVR4 style systems (including solaris) its called
truss. Under many BSD systems its called ktrace. </P
><P
>The first thing you should do is read the man page for your native
system call tracer. In the discussion below I'll assume its called
strace as strace is the only portable system tracer (its available for
free for many unix types) and its also got some of the nicest
features.</P
><P
>Next, try using strace on some simple commands. For example, <B
CLASS="COMMAND"
>strace
ls</B
> or <B
CLASS="COMMAND"
>strace echo hello</B
>.</P
><P
> 
You'll notice that it produces a LOT of output. It is showing you the
arguments to every system call that the program makes and the
result. Very little happens in a program without a system call so you
get lots of output. You'll also find that it produces a lot of
"preamble" stuff showing the loading of shared libraries etc. Ignore
this (unless its going wrong!)</P
><P
>For example, the only line that really matters in the <B
CLASS="COMMAND"
>strace echo
hello</B
> output is:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>write(1, "hello\n", 6)                  = 6</PRE
></P
><P
>all the rest is just setting up to run the program.</P
><P
>Ok, now you're familiar with strace. To use it on Samba you need to
strace the running smbd daemon. The way I tend ot use it is to first
login from my Windows PC to the Samba server, then use smbstatus to
find which process ID that client is attached to, then as root I do
<B
CLASS="COMMAND"
>strace -p PID</B
> to attach to that process. I normally redirect the
stderr output from this command to a file for later perusal. For
example, if I'm using a csh style shell:</P
><P
><B
CLASS="COMMAND"
>strace -f -p 3872 &#62;&#38; strace.out</B
></P
><P
>or with a sh style shell:</P
><P
><B
CLASS="COMMAND"
>strace -f -p 3872 &#62; strace.out 2&#62;&#38;1</B
></P
><P
>Note the "-f" option. This is only available on some systems, and
allows you to trace not just the current process, but any children it
forks. This is great for finding printing problems caused by the
"print command" being wrong.</P
><P
>Once you are attached you then can do whatever it is on the client
that is causing problems and you will capture all the system calls
that smbd makes. </P
><P
>So how do you interpret the results? Generally I search through the
output for strings that I know will appear when the problem
happens. For example, if I am having touble with permissions on a file
I would search for that files name in the strace output and look at
the surrounding lines. Another trick is to match up file descriptor
numbers and "follow" what happens to an open file until it is closed.</P
><P
>Beyond this you will have to use your initiative. To give you an idea
of what you are looking for here is a piece of strace output that
shows that <TT
CLASS="FILENAME"
>/dev/null</TT
> is not world writeable, which
causes printing to fail with Samba:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>[pid 28268] open("/dev/null", O_RDWR)   = -1 EACCES (Permission denied)
[pid 28268] open("/dev/null", O_WRONLY) = -1 EACCES (Permission denied)</PRE
></P
><P
>The process is trying to first open <TT
CLASS="FILENAME"
>/dev/null</TT
> read-write 
then read-only. Both fail. This means <TT
CLASS="FILENAME"
>/dev/null</TT
> has 
incorrect permissions.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NTDOMAIN"
></A
>Chapter 9. NT Domain RPC's</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN652"
></A
>9.1. Introduction</H2
><P
>This document contains information to provide an NT workstation with login
services, without the need for an NT server. It is the sgml version of <A
HREF="http://mailhost.cb1.com/~lkcl/cifsntdomain.txt"
TARGET="_top"
>http://mailhost.cb1.com/~lkcl/cifsntdomain.txt</A
>, controlled by Luke.</P
><P
>It should be possible to select a domain instead of a workgroup (in the NT
workstation's TCP/IP settings) and after the obligatory reboot, type in a
username, password, select a domain and successfully log in.  I would
appreciate any feedback on your experiences with this process, and any
comments, corrections and additions to this document.</P
><P
>The packets described here can be easily derived from (and are probably
better understood using) Netmon.exe.  You will need to use the version
of Netmon that matches your system, in order to correctly decode the
NETLOGON, lsarpc and srvsvc Transact pipes.  This document is derived from
NT Service Pack 1 and its corresponding version of Netmon.  It is intended
that an annotated packet trace be produced, which will likely be more
instructive than this document.</P
><P
>Also needed, to fully implement NT Domain Login Services, is the 
document describing the cryptographic part of the NT authentication.
This document is available from comp.protocols.smb; from the ntsecurity.net
digest and from the samba digest, amongst other sources.</P
><P
>A copy is available from:</P
><P
><A
HREF="http://ntbugtraq.rc.on.ca/SCRIPTS/WA.EXE?A2=ind9708;L=ntbugtraq;O=A;P=2935"
TARGET="_top"
>http://ntbugtraq.rc.on.ca/SCRIPTS/WA.EXE?A2=ind9708;L=ntbugtraq;O=A;P=2935</A
></P
><P
><A
HREF="http://mailhost.cb1.com/~lkcl/crypt.html"
TARGET="_top"
>http://mailhost.cb1.com/~lkcl/crypt.html</A
></P
><P
>A c-code implementation, provided by <A
HREF="mailto:linus@incolumitas.se"
TARGET="_top"
>Linus Nordberg</A
>
of this protocol is available from:</P
><P
><A
HREF="http://samba.org/cgi-bin/mfs/01/digest/1997/97aug/0391.html"
TARGET="_top"
>http://samba.org/cgi-bin/mfs/01/digest/1997/97aug/0391.html</A
></P
><P
><A
HREF="http://mailhost.cb1.com/~lkcl/crypt.txt"
TARGET="_top"
>http://mailhost.cb1.com/~lkcl/crypt.txt</A
></P
><P
>Also used to provide debugging information is the Check Build version of
NT workstation, and enabling full debugging in NETLOGON.  This is
achieved by setting the following REG_SZ registry key to 0x1ffffff:</P
><P
><TT
CLASS="FILENAME"
>HKLM\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters</TT
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Incorrect direct editing of the registry can cause your
machine to fail. Then again, so can incorrect implementation of this 
protocol. See "Liability:" above.</I
></SPAN
></P
><P
>Bear in mind that each packet over-the-wire will have its origin in an
API call.  Therefore, there are likely to be structures, enumerations
and defines that are usefully documented elsewhere.</P
><P
>This document is by no means complete or authoritative.  Missing sections
include, but are not limited to:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Mappings of RIDs to usernames (and vice-versa).</P
></LI
><LI
><P
>What a User ID is and what a Group ID is.</P
></LI
><LI
><P
>The exact meaning/definition of various magic constants or enumerations.</P
></LI
><LI
><P
>The reply error code and use of that error code when a
workstation becomes a member of a domain (to be described later).  
Failure to return this error code will make the workstation report 
that it is already a member of the domain.</P
></LI
><LI
><P
>the cryptographic side of the NetrServerPasswordSet command, 
which would allow the workstation to change its password.  This password is
used to generate the long-term session key.  [It is possible to reject this
command, and keep the default workstation password].</P
></LI
></OL
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN688"
></A
>9.1.1. Sources</H3
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>cket Traces from Netmonitor (Service Pack 1 and above)</TD
></TR
><TR
><TD
>ul Ashton and Luke Leighton's other "NT Domain" doc.</TD
></TR
><TR
><TD
>FS documentation - cifs6.txt</TD
></TR
><TR
><TD
>FS documentation - cifsrap2.txt</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN695"
></A
>9.1.2. Credits</H3
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>Paul Ashton: loads of work with Net Monitor; understanding the NT authentication system; reference implementation of the NT domain support on which this document is originally based.</TD
></TR
><TR
><TD
>Duncan Stansfield: low-level analysis of MSRPC Pipes.</TD
></TR
><TR
><TD
>Linus Nordberg: producing c-code from Paul's crypto spec.</TD
></TR
><TR
><TD
>Windows Sourcer development team</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN702"
></A
>9.2. Notes and Structures</H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN704"
></A
>9.2.1. Notes</H3
><P
></P
><OL
TYPE="1"
><LI
><P
>In the SMB Transact pipes, some "Structures", described here, appear to be
4-byte aligned with the SMB header, at their start.  Exactly which
"Structures" need aligning is not precisely known or documented.</P
></LI
><LI
><P
>In the UDP NTLOGON Mailslots, some "Structures", described here, appear to be
2-byte aligned with the start of the mailslot, at their start.</P
></LI
><LI
><P
>Domain SID is of the format S-revision-version-auth1-auth2...authN.
e.g S-1-5-123-456-789-123-456.  the 5 could be a sub-revision.</P
></LI
><LI
><P
>any undocumented buffer pointers must be non-zero if the string buffer it
refers to contains characters.  exactly what value they should be is unknown.
0x0000 0002 seems to do the trick to indicate that the buffer exists.  a
NULL buffer pointer indicates that the string buffer is of zero length.
If the buffer pointer is NULL, then it is suspected that the structure it
refers to is NOT put into (or taken out of) the SMB data stream.  This is
empirically derived from, for example, the LSA SAM Logon response packet,
where if the buffer pointer is NULL, the user information is not inserted
into the data stream.  Exactly what happens with an array of buffer pointers
is not known, although an educated guess can be made.</P
></LI
><LI
><P
>an array of structures (a container) appears to have a count and a pointer.
if the count is zero, the pointer is also zero.  no further data is put
into or taken out of the SMB data stream.  if the count is non-zero, then
the pointer is also non-zero.  immediately following the pointer is the
count again, followed by an array of container sub-structures.  the count
appears a third time after the last sub-structure.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN717"
></A
>9.2.2. Enumerations</H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN719"
></A
>9.2.2.1. MSRPC Header type</H4
><P
>command number in the msrpc packet header</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>MSRPC_Request:</DT
><DD
><P
>0x00</P
></DD
><DT
>MSRPC_Response:</DT
><DD
><P
>0x02</P
></DD
><DT
>MSRPC_Bind:</DT
><DD
><P
>0x0B</P
></DD
><DT
>MSRPC_BindAck:</DT
><DD
><P
>0x0C</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN739"
></A
>9.2.2.2. MSRPC Packet info</H4
><P
>The meaning of these flags is undocumented</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>FirstFrag:</DT
><DD
><P
>0x01 </P
></DD
><DT
>LastFrag:</DT
><DD
><P
>0x02 </P
></DD
><DT
>NotaFrag:</DT
><DD
><P
>0x04  </P
></DD
><DT
>RecRespond:</DT
><DD
><P
>0x08  </P
></DD
><DT
>NoMultiplex:</DT
><DD
><P
>0x10  </P
></DD
><DT
>NotForIdemp:</DT
><DD
><P
>0x20  </P
></DD
><DT
>NotforBcast:</DT
><DD
><P
>0x40  </P
></DD
><DT
>NoUuid:</DT
><DD
><P
>0x80 </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN775"
></A
>9.2.3. Structures</H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN777"
></A
>9.2.3.1. VOID *</H4
><P
>sizeof VOID* is 32 bits.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN780"
></A
>9.2.3.2. char</H4
><P
>sizeof char is 8 bits.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN783"
></A
>9.2.3.3. UTIME</H4
><P
>UTIME is 32 bits, indicating time in seconds since 01jan1970.  documented in cifs6.txt (section 3.5 page, page 30).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN786"
></A
>9.2.3.4. NTTIME</H4
><P
>NTTIME is 64 bits.  documented in cifs6.txt (section 3.5 page, page 30).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN789"
></A
>9.2.3.5. DOM_SID (domain SID structure)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>num of sub-authorities in domain SID</P
></DD
><DT
>UINT8</DT
><DD
><P
>SID revision number</P
></DD
><DT
>UINT8</DT
><DD
><P
>num of sub-authorities in domain SID</P
></DD
><DT
>UINT8[6]</DT
><DD
><P
>6 bytes for domain SID - Identifier Authority.</P
></DD
><DT
>UINT16[n_subauths]</DT
><DD
><P
>domain SID sub-authorities</P
></DD
></DL
></DIV
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: the domain SID is documented elsewhere.</I
></SPAN
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN814"
></A
>9.2.3.6. STR (string)</H4
><P
>STR (string) is a char[] : a null-terminated string of ascii characters.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN817"
></A
>9.2.3.7. UNIHDR (unicode string header)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16</DT
><DD
><P
>length of unicode string</P
></DD
><DT
>UINT16</DT
><DD
><P
>max length of unicode string</P
></DD
><DT
>UINT32</DT
><DD
><P
>4 - undocumented.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN832"
></A
>9.2.3.8. UNIHDR2 (unicode string header plus buffer pointer)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UNIHDR</DT
><DD
><P
>unicode string header</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN843"
></A
>9.2.3.9. UNISTR (unicode string)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16[]</DT
><DD
><P
>null-terminated string of unicode characters.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN850"
></A
>9.2.3.10. NAME (length-indicated unicode string)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>length of unicode string</P
></DD
><DT
>UINT16[]</DT
><DD
><P
>null-terminated string of unicode characters.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN861"
></A
>9.2.3.11. UNISTR2 (aligned unicode string)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT8[]</DT
><DD
><P
>padding to get unicode string 4-byte aligned with the start of the SMB header.</P
></DD
><DT
>UINT32</DT
><DD
><P
>max length of unicode string</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - undocumented</P
></DD
><DT
>UINT32</DT
><DD
><P
>length of unicode string</P
></DD
><DT
>UINT16[]</DT
><DD
><P
>string of uncode characters</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN884"
></A
>9.2.3.12. OBJ_ATTR (object attributes)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>0x18 - length (in bytes) including the length field.</P
></DD
><DT
>VOID*</DT
><DD
><P
>0 - root directory (pointer)</P
></DD
><DT
>VOID*</DT
><DD
><P
>0 - object name (pointer)</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - attributes (undocumented)</P
></DD
><DT
>VOID*</DT
><DD
><P
>0 - security descriptior (pointer)</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - security quality of service</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN911"
></A
>9.2.3.13. POL_HND (LSA policy handle)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>char[20]</DT
><DD
><P
>policy handle</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN918"
></A
>9.2.3.14. DOM_SID2 (domain SID structure, SIDS stored in unicode)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>5 - SID type</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - undocumented</P
></DD
><DT
>UNIHDR2</DT
><DD
><P
>domain SID unicode string header</P
></DD
><DT
>UNISTR</DT
><DD
><P
>domain SID unicode string</P
></DD
></DL
></DIV
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	there is a conflict between the unicode string header and the unicode string itself as to which to use to indicate string length.  this will need to be resolved.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	the SID type indicates, for example, an alias; a well-known group etc. this is documented somewhere.</I
></SPAN
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN941"
></A
>9.2.3.15. DOM_RID (domain RID structure)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>5 - well-known SID.  1 - user SID (see ShowACLs)</P
></DD
><DT
>UINT32</DT
><DD
><P
>5 - undocumented</P
></DD
><DT
>UINT32</DT
><DD
><P
>domain RID </P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - domain index out of above reference domains</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN960"
></A
>9.2.3.16. LOG_INFO (server, account, client structure)</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	logon server name starts with two '\' characters and is upper case.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	account name is the logon client name from the LSA Request Challenge, with a $ on the end of it, in upper case.</I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon server unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>account name unicode string</P
></DD
><DT
>UINT16</DT
><DD
><P
>sec_chan - security channel type</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon client machine unicode string</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN987"
></A
>9.2.3.17. CLNT_SRV (server, client names structure)</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	logon server name starts with two '\' characters and is upper case.</I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon server unicode string</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon client machine unicode string</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1008"
></A
>9.2.3.18. CREDS (credentials + time stamp)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>char[8]</DT
><DD
><P
>credentials</P
></DD
><DT
>UTIME</DT
><DD
><P
>time stamp</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1019"
></A
>9.2.3.19. CLNT_INFO2 (server, client structure, client credentials)</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: whenever this structure appears in a request, you must take a copy of the client-calculated credentials received, because they will beused in subsequent credential checks.  the presumed intention is to
	maintain an authenticated request/response trail.</I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>CLNT_SRV</DT
><DD
><P
>client and server names</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>???? padding, for 4-byte alignment with SMB header.</P
></DD
><DT
>VOID*</DT
><DD
><P
>pointer to client credentials.</P
></DD
><DT
>CREDS</DT
><DD
><P
>client-calculated credentials + client time</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1040"
></A
>9.2.3.20. CLNT_INFO (server, account, client structure, client credentials)</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: whenever this structure appears in a request, you must take a copy of the client-calculated credentials received, because they will be used in subsequent credential checks.  the presumed intention is to maintain an authenticated request/response trail.</I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>LOG_INFO</DT
><DD
><P
>logon account info</P
></DD
><DT
>CREDS</DT
><DD
><P
>client-calculated credentials + client time</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1053"
></A
>9.2.3.21. ID_INFO_1 (id info structure, auth level 1)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>ptr_id_info_1</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>domain name unicode header</P
></DD
><DT
>UINT32</DT
><DD
><P
>param control</P
></DD
><DT
>UINT64</DT
><DD
><P
>logon ID</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>user name unicode header</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>workgroup name unicode header</P
></DD
><DT
>char[16]</DT
><DD
><P
>arc4 LM OWF Password</P
></DD
><DT
>char[16]</DT
><DD
><P
>arc4 NT OWF Password</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>domain name unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>user name unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>workstation name unicode string</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1100"
></A
>9.2.3.22. SAM_INFO (sam logon/logoff id info structure)</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: presumably, the return credentials is supposedly for the server to verify that the credential chain hasn't been compromised.</I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>CLNT_INFO2</DT
><DD
><P
>client identification/authentication info</P
></DD
><DT
>VOID*</DT
><DD
><P
>pointer to return credentials.</P
></DD
><DT
>CRED</DT
><DD
><P
>return credentials - ignored.</P
></DD
><DT
>UINT16</DT
><DD
><P
>logon level</P
></DD
><DT
>UINT16</DT
><DD
><P
>switch value</P
></DD
></DL
></DIV
><P
><PRE
CLASS="PROGRAMLISTING"
>        switch (switch_value)
        case 1:
        {
            ID_INFO_1     id_info_1;
        }</PRE
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1127"
></A
>9.2.3.23. GID (group id info)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>group id</P
></DD
><DT
>UINT32</DT
><DD
><P
>user attributes (only used by NT 3.1 and 3.51)</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1138"
></A
>9.2.3.24. DOM_REF (domain reference info)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer.</P
></DD
><DT
>UINT32</DT
><DD
><P
>num referenced domains?</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented domain name buffer pointer.</P
></DD
><DT
>UINT32</DT
><DD
><P
>32 - max number of entries</P
></DD
><DT
>UINT32</DT
><DD
><P
>4 - num referenced domains?</P
></DD
><DT
>UNIHDR2</DT
><DD
><P
>domain name unicode string header</P
></DD
><DT
>UNIHDR2[num_ref_doms-1]</DT
><DD
><P
>referenced domain unicode string headers</P
></DD
><DT
>UNISTR</DT
><DD
><P
>domain name unicode string</P
></DD
><DT
>DOM_SID[num_ref_doms]</DT
><DD
><P
>referenced domain SIDs</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1177"
></A
>9.2.3.25. DOM_INFO (domain info, levels 3 and 5 are the same))</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT8[]</DT
><DD
><P
>??? padding to get 4-byte alignment with start of SMB header</P
></DD
><DT
>UINT16</DT
><DD
><P
>domain name string length * 2</P
></DD
><DT
>UINT16</DT
><DD
><P
>domain name string length * 2</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented domain name string buffer pointer</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented domain SID string buffer pointer</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>domain name (unicode string)</P
></DD
><DT
>DOM_SID</DT
><DD
><P
>domain SID</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1208"
></A
>9.2.3.26. USER_INFO (user logon info)</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: it would be nice to know what the 16 byte user session key is for.</I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>NTTIME</DT
><DD
><P
>logon time</P
></DD
><DT
>NTTIME</DT
><DD
><P
>logoff time</P
></DD
><DT
>NTTIME</DT
><DD
><P
>kickoff time</P
></DD
><DT
>NTTIME</DT
><DD
><P
>password last set time</P
></DD
><DT
>NTTIME</DT
><DD
><P
>password can change time</P
></DD
><DT
>NTTIME</DT
><DD
><P
>password must change time</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>username unicode string header</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>user's full name unicode string header</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>logon script unicode string header</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>profile path unicode string header</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>home directory unicode string header</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>home directory drive unicode string header</P
></DD
><DT
>UINT16</DT
><DD
><P
>logon count</P
></DD
><DT
>UINT16</DT
><DD
><P
>bad password count</P
></DD
><DT
>UINT32</DT
><DD
><P
>User ID</P
></DD
><DT
>UINT32</DT
><DD
><P
>Group ID</P
></DD
><DT
>UINT32</DT
><DD
><P
>num groups</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer to groups.</P
></DD
><DT
>UINT32</DT
><DD
><P
>user flags</P
></DD
><DT
>char[16]</DT
><DD
><P
>user session key</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>logon server unicode string header</P
></DD
><DT
>UNIHDR</DT
><DD
><P
>logon domain unicode string header</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented logon domain id pointer</P
></DD
><DT
>char[40]</DT
><DD
><P
>40 undocumented padding bytes.  future expansion?</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - num_other_sids?</P
></DD
><DT
>VOID*</DT
><DD
><P
>NULL - undocumented pointer to other domain SIDs.</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>username unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>user's full name unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon script unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>profile path unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>home directory unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>home directory drive unicode string</P
></DD
><DT
>UINT32</DT
><DD
><P
>num groups</P
></DD
><DT
>GID[num_groups]</DT
><DD
><P
>group info</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon server unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon domain unicode string</P
></DD
><DT
>DOM_SID</DT
><DD
><P
>domain SID</P
></DD
><DT
>DOM_SID[num_sids]</DT
><DD
><P
>other domain SIDs?</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1365"
></A
>9.2.3.27. SH_INFO_1_PTR (pointers to level 1 share info strings)</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	see cifsrap2.txt section5, page 10.</I
></SPAN
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>0 for shi1_type indicates a  Disk.</TD
></TR
><TR
><TD
>1 for shi1_type indicates a  Print Queue.</TD
></TR
><TR
><TD
>2 for shi1_type indicates a  Device.</TD
></TR
><TR
><TD
>3 for shi1_type indicates an IPC pipe.</TD
></TR
><TR
><TD
>0x8000 0000 (top bit set in shi1_type) indicates a hidden share.</TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>shi1_netname - pointer to net name</P
></DD
><DT
>UINT32</DT
><DD
><P
>shi1_type    - type of share.  0 - undocumented.</P
></DD
><DT
>VOID*</DT
><DD
><P
>shi1_remark  - pointer to comment.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1388"
></A
>9.2.3.28. SH_INFO_1_STR (level 1 share info strings)</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UNISTR2</DT
><DD
><P
>shi1_netname - unicode string of net name</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>shi1_remark  - unicode string of comment.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1399"
></A
>9.2.3.29. SHARE_INFO_1_CTR</H4
><P
>share container with 0 entries:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>0 - EntriesRead</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - Buffer</P
></DD
></DL
></DIV
><P
>share container with &#62; 0 entries:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>EntriesRead</P
></DD
><DT
>UINT32</DT
><DD
><P
>non-zero - Buffer</P
></DD
><DT
>UINT32</DT
><DD
><P
>EntriesRead</P
></DD
><DT
>SH_INFO_1_PTR[EntriesRead]</DT
><DD
><P
>share entry pointers</P
></DD
><DT
>SH_INFO_1_STR[EntriesRead]</DT
><DD
><P
>share entry strings</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>padding to get unicode string 4-byte aligned with start of the SMB header.</P
></DD
><DT
>UINT32</DT
><DD
><P
>EntriesRead</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - padding</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1445"
></A
>9.2.3.30. SERVER_INFO_101</H4
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	see cifs6.txt section 6.4 - the fields described therein will be of assistance here.  for example, the type listed below is the 	same as fServerType, which is described in 6.4.1. </I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>SV_TYPE_WORKSTATION</DT
><DD
><P
>0x00000001  All workstations</P
></DD
><DT
>SV_TYPE_SERVER</DT
><DD
><P
>0x00000002  All servers</P
></DD
><DT
>SV_TYPE_SQLSERVER</DT
><DD
><P
>0x00000004  Any server running with SQL server</P
></DD
><DT
>SV_TYPE_DOMAIN_CTRL</DT
><DD
><P
>0x00000008  Primary domain controller</P
></DD
><DT
>SV_TYPE_DOMAIN_BAKCTRL</DT
><DD
><P
>0x00000010  Backup domain controller</P
></DD
><DT
>SV_TYPE_TIME_SOURCE</DT
><DD
><P
>0x00000020  Server running the timesource service</P
></DD
><DT
>SV_TYPE_AFP</DT
><DD
><P
>0x00000040  Apple File Protocol servers</P
></DD
><DT
>SV_TYPE_NOVELL</DT
><DD
><P
>0x00000080  Novell servers</P
></DD
><DT
>SV_TYPE_DOMAIN_MEMBER</DT
><DD
><P
>0x00000100  Domain Member</P
></DD
><DT
>SV_TYPE_PRINTQ_SERVER</DT
><DD
><P
>0x00000200  Server sharing print queue</P
></DD
><DT
>SV_TYPE_DIALIN_SERVER</DT
><DD
><P
>0x00000400  Server running dialin service.</P
></DD
><DT
>SV_TYPE_XENIX_SERVER</DT
><DD
><P
>0x00000800  Xenix server</P
></DD
><DT
>SV_TYPE_NT</DT
><DD
><P
>0x00001000  NT server</P
></DD
><DT
>SV_TYPE_WFW</DT
><DD
><P
>0x00002000  Server running Windows for </P
></DD
><DT
>SV_TYPE_SERVER_NT</DT
><DD
><P
>0x00008000  Windows NT non DC server</P
></DD
><DT
>SV_TYPE_POTENTIAL_BROWSER</DT
><DD
><P
>0x00010000  Server that can run the browser service</P
></DD
><DT
>SV_TYPE_BACKUP_BROWSER</DT
><DD
><P
>0x00020000  Backup browser server</P
></DD
><DT
>SV_TYPE_MASTER_BROWSER</DT
><DD
><P
>0x00040000  Master browser server</P
></DD
><DT
>SV_TYPE_DOMAIN_MASTER</DT
><DD
><P
>0x00080000  Domain Master Browser server</P
></DD
><DT
>SV_TYPE_LOCAL_LIST_ONLY</DT
><DD
><P
>0x40000000  Enumerate only entries marked "local"</P
></DD
><DT
>SV_TYPE_DOMAIN_ENUM</DT
><DD
><P
>0x80000000  Enumerate Domains. The pszServer and pszDomain parameters must be NULL.</P
></DD
></DL
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>500 - platform_id</P
></DD
><DT
>VOID*</DT
><DD
><P
>pointer to name</P
></DD
><DT
>UINT32</DT
><DD
><P
>5 - major version</P
></DD
><DT
>UINT32</DT
><DD
><P
>4 - minor version</P
></DD
><DT
>UINT32</DT
><DD
><P
>type (SV_TYPE_... bit field)</P
></DD
><DT
>VOID*</DT
><DD
><P
>pointer to comment</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>sv101_name - unicode string of server name</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>sv_101_comment  - unicode string of server comment.</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>padding to get unicode string 4-byte aligned with start of the SMB header.</P
></DD
></DL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1571"
></A
>9.3. MSRPC over Transact Named Pipe</H2
><P
>For details on the SMB Transact Named Pipe, see cifs6.txt</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1574"
></A
>9.3.1. MSRPC Pipes</H3
><P
>The MSRPC is conducted over an SMB Transact Pipe with a name of 
<TT
CLASS="FILENAME"
>\PIPE\</TT
>.  You must first obtain a 16 bit file handle, by
sending a SMBopenX with the pipe name <TT
CLASS="FILENAME"
>\PIPE\srvsvc</TT
> for
example.  You can then perform an SMB Trans,
and must carry out an SMBclose on the file handle once you are finished.</P
><P
>Trans Requests must be sent with two setup UINT16s, no UINT16 params (none
known about), and UINT8 data parameters sufficient to contain the MSRPC
header, and MSRPC data.  The first UINT16 setup parameter must be either
0x0026 to indicate an RPC, or 0x0001 to indicate Set Named Pipe Handle
state.  The second UINT16 parameter must be the file handle for the pipe,
obtained above.</P
><P
>The Data section for an API Command of 0x0026 (RPC pipe) in the Trans
Request is the RPC Header, followed by the RPC Data.  The Data section for
an API Command of 0x0001 (Set Named Pipe Handle state) is two bytes.  The
only value seen for these two bytes is 0x00 0x43.</P
><P
>MSRPC Responses are sent as response data inside standard SMB Trans
responses, with the MSRPC Header, MSRPC Data and MSRPC tail.</P
><P
>It is suspected that the Trans Requests will need to be at least 2-byte
aligned (probably 4-byte).  This is standard practice for SMBs.  It is also
independent of the observed 4-byte alignments with the start of the MSRPC
header, including the 4-byte alignment between the MSRPC header and the
MSRPC data.</P
><P
>First, an SMBtconX connection is made to the IPC$ share.  The connection
must be made using encrypted passwords, not clear-text.  Then, an SMBopenX
is made on the pipe.  Then, a Set Named Pipe Handle State must be sent,
after which the pipe is ready to accept API commands.  Lastly, and SMBclose
is sent.</P
><P
>To be resolved:</P
><P
>lkcl/01nov97 there appear to be two additional bytes after the null-terminated \PIPE\ name for the RPC pipe.  Values seen so far are
listed below:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>        initial SMBopenX request:         RPC API command 0x26 params:
        "\\PIPE\\lsarpc"                  0x65 0x63; 0x72 0x70; 0x44 0x65;
        "\\PIPE\\srvsvc"                  0x73 0x76; 0x4E 0x00; 0x5C 0x43;</PRE
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1588"
></A
>9.3.2. Header</H3
><P
>[section to be rewritten, following receipt of work by Duncan Stansfield]</P
><P
>Interesting note: if you set packed data representation to 0x0100 0000
then all 4-byte and 2-byte word ordering is turned around!</P
><P
>The start of each of the NTLSA and NETLOGON named pipes begins with:</P
><P
><B
>offset: </B
>00</P
><P
><B
>Variable type: </B
>UINT8</P
><P
><B
>Variable data: </B
>5 - RPC major version</P
><P
><B
>offset: </B
>01</P
><P
><B
>Variable type: </B
>UINT8</P
><P
><B
>Variable data: </B
>0 - RPC minor version</P
><P
><B
>offset: </B
>02</P
><P
><B
>Variable type: </B
>UINT8</P
><P
><B
>Variable data: </B
>2 - RPC response packet</P
><P
><B
>offset: </B
>03</P
><P
><B
>Variable type: </B
>UINT8</P
><P
><B
>Variable data: </B
>3 - (FirstFrag bit-wise or with LastFrag)</P
><P
><B
>offset: </B
>04</P
><P
><B
>Variable type: </B
>UINT32</P
><P
><B
>Variable data: </B
>0x1000 0000 - packed data representation</P
><P
><B
>offset: </B
>08</P
><P
><B
>Variable type: </B
>UINT16</P
><P
><B
>Variable data: </B
>fragment length - data size (bytes) inc header and tail.</P
><P
><B
>offset: </B
>0A</P
><P
><B
>Variable type: </B
>UINT16</P
><P
><B
>Variable data: </B
>0 - authentication length </P
><P
><B
>offset: </B
>0C</P
><P
><B
>Variable type: </B
>UINT32</P
><P
><B
>Variable data: </B
>call identifier. matches 12th UINT32 of incoming RPC data.</P
><P
><B
>offset: </B
>10</P
><P
><B
>Variable type: </B
>UINT32</P
><P
><B
>Variable data: </B
>allocation hint - data size (bytes) minus header and tail.</P
><P
><B
>offset: </B
>14</P
><P
><B
>Variable type: </B
>UINT16</P
><P
><B
>Variable data: </B
>0 - presentation context identifier</P
><P
><B
>offset: </B
>16</P
><P
><B
>Variable type: </B
>UINT8</P
><P
><B
>Variable data: </B
>0 - cancel count</P
><P
><B
>offset: </B
>17</P
><P
><B
>Variable type: </B
>UINT8</P
><P
><B
>Variable data: </B
>in replies: 0 - reserved; in requests: opnum - see #defines.</P
><P
><B
>offset: </B
>18</P
><P
><B
>Variable type: </B
>......</P
><P
><B
>Variable data: </B
>start of data (goes on for allocation_hint bytes)</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1649"
></A
>9.3.2.1. RPC_Packet for request, response, bind and bind acknowledgement</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT8 versionmaj</DT
><DD
><P
>reply same as request (0x05)</P
></DD
><DT
>UINT8 versionmin</DT
><DD
><P
>reply same as request (0x00)</P
></DD
><DT
>UINT8 type</DT
><DD
><P
>one of the MSRPC_Type enums</P
></DD
><DT
>UINT8 flags</DT
><DD
><P
>reply same as request (0x00 for Bind, 0x03 for Request)</P
></DD
><DT
>UINT32 representation</DT
><DD
><P
>reply same as request (0x00000010)</P
></DD
><DT
>UINT16 fraglength</DT
><DD
><P
>the length of the data section of the SMB trans packet</P
></DD
><DT
>UINT16 authlength</DT
><DD
><P
></P
></DD
><DT
>UINT32 callid</DT
><DD
><P
>call identifier. (e.g. 0x00149594)</P
></DD
><DT
>* stub USE TvPacket</DT
><DD
><P
>the remainder of the packet depending on the "type"</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1688"
></A
>9.3.2.2. Interface identification</H4
><P
>the interfaces are numbered. as yet I haven't seen more than one interface used on the same pipe name srvsvc</P
><P
><PRE
CLASS="PROGRAMLISTING"
>abstract (0x4B324FC8, 0x01D31670, 0x475A7812, 0x88E16EBF, 0x00000003)
transfer (0x8A885D04, 0x11C91CEB, 0x0008E89F, 0x6048102B, 0x00000002)</PRE
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1693"
></A
>9.3.2.3. RPC_Iface RW</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT8 byte[16]</DT
><DD
><P
>16 bytes of number</P
></DD
><DT
>UINT32 version</DT
><DD
><P
>the interface number</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1704"
></A
>9.3.2.4. RPC_ReqBind RW</H4
><P
>the remainder of the packet after the header if "type" was Bind in the response header, "type" should be BindAck</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16 maxtsize</DT
><DD
><P
>maximum transmission fragment size (0x1630)</P
></DD
><DT
>UINT16 maxrsize</DT
><DD
><P
>max receive fragment size (0x1630)</P
></DD
><DT
>UINT32 assocgid</DT
><DD
><P
>associated group id (0x0)</P
></DD
><DT
>UINT32 numelements</DT
><DD
><P
>the number of elements (0x1)</P
></DD
><DT
>UINT16 contextid</DT
><DD
><P
>presentation context identifier (0x0)</P
></DD
><DT
>UINT8 numsyntaxes</DT
><DD
><P
>the number of syntaxes (has always been 1?)(0x1)</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>4-byte alignment padding, against SMB header</P
></DD
><DT
>* abstractint USE RPC_Iface</DT
><DD
><P
>num and vers. of interface client is using</P
></DD
><DT
>* transferint USE RPC_Iface</DT
><DD
><P
>num and vers. of interface to use for replies</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1744"
></A
>9.3.2.5. RPC_Address RW</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16 length</DT
><DD
><P
>length of the string including null terminator</P
></DD
><DT
>* port USE string</DT
><DD
><P
>the string above in single byte, null terminated form</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1755"
></A
>9.3.2.6. RPC_ResBind RW</H4
><P
>the response to place after the header in the reply packet</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16 maxtsize</DT
><DD
><P
>same as request</P
></DD
><DT
>UINT16 maxrsize</DT
><DD
><P
>same as request</P
></DD
><DT
>UINT32 assocgid</DT
><DD
><P
>zero</P
></DD
><DT
>* secondaddr USE RPC_Address</DT
><DD
><P
>the address string, as described earlier</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>4-byte alignment padding, against SMB header</P
></DD
><DT
>UINT8 numresults</DT
><DD
><P
>the number of results (0x01)</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>4-byte alignment padding, against SMB header</P
></DD
><DT
>UINT16 result</DT
><DD
><P
>result (0x00 = accept)</P
></DD
><DT
>UINT16 reason</DT
><DD
><P
>reason (0x00 = no reason specified)</P
></DD
><DT
>* transfersyntax USE RPC_Iface</DT
><DD
><P
>the transfer syntax from the request</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1799"
></A
>9.3.2.7. RPC_ReqNorm RW</H4
><P
>the remainder of the packet after the header for every other other request</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32 allochint</DT
><DD
><P
>the size of the stub data in bytes</P
></DD
><DT
>UINT16 prescontext</DT
><DD
><P
>presentation context identifier (0x0)</P
></DD
><DT
>UINT16 opnum</DT
><DD
><P
>operation number (0x15)</P
></DD
><DT
>* stub USE TvPacket</DT
><DD
><P
>a packet dependent on the pipe name (probably the interface) and the op number)</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1819"
></A
>9.3.2.8. RPC_ResNorm RW</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32 allochint</DT
><DD
><P
># size of the stub data in bytes</P
></DD
><DT
>UINT16 prescontext</DT
><DD
><P
># presentation context identifier (same as request)</P
></DD
><DT
>UINT8 cancelcount</DT
><DD
><P
># cancel count? (0x0)</P
></DD
><DT
>UINT8 reserved</DT
><DD
><P
># 0 - one byte padding</P
></DD
><DT
>* stub USE TvPacket</DT
><DD
><P
># the remainder of the reply</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1842"
></A
>9.3.3. Tail</H3
><P
>The end of each of the NTLSA and NETLOGON named pipes ends with:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>......</DT
><DD
><P
>end of data</P
></DD
><DT
>UINT32</DT
><DD
><P
>return code</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1854"
></A
>9.3.4. RPC Bind / Bind Ack</H3
><P
>RPC Binds are the process of associating an RPC pipe (e.g \PIPE\lsarpc)
with a "transfer syntax" (see RPC_Iface structure).  The purpose for doing
this is unknown.</P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: The RPC_ResBind SMB Transact request is sent with two uint16 setup parameters.  The first is 0x0026; the second is the file handle
	returned by the SMBopenX Transact response.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	The RPC_ResBind members maxtsize, maxrsize and assocgid are the same in the response as the same members in the RPC_ReqBind.  The
	RPC_ResBind member transfersyntax is the same in the response as
	the</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	The RPC_ResBind response member secondaddr contains the name of what is presumed to be the service behind the RPC pipe.  The
	mapping identified so far is:</I
></SPAN
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>initial SMBopenX request:</DT
><DD
><P
>RPC_ResBind response:</P
></DD
><DT
>"\\PIPE\\srvsvc"</DT
><DD
><P
>"\\PIPE\\ntsvcs"</P
></DD
><DT
>"\\PIPE\\samr"</DT
><DD
><P
>"\\PIPE\\lsass"</P
></DD
><DT
>"\\PIPE\\lsarpc"</DT
><DD
><P
>"\\PIPE\\lsass"</P
></DD
><DT
>"\\PIPE\\wkssvc"</DT
><DD
><P
>"\\PIPE\\wksvcs"</P
></DD
><DT
>"\\PIPE\\NETLOGON"</DT
><DD
><P
>"\\PIPE\\NETLOGON"</P
></DD
></DL
></DIV
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	The RPC_Packet fraglength member in both the Bind Request and Bind Acknowledgment must contain the length of the entire RPC data, including the RPC_Packet header.</I
></SPAN
></P
><P
>Request:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>RPC_Packet</TD
></TR
><TR
><TD
>RPC_ReqBind</TD
></TR
></TBODY
></TABLE
><P
></P
><P
>Response:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>RPC_Packet</TD
></TR
><TR
><TD
>RPC_ResBind</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1898"
></A
>9.3.5. NTLSA Transact Named Pipe</H3
><P
>The sequence of actions taken on this pipe are:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>Establish a connection to the IPC$ share (SMBtconX).  use encrypted passwords.</TD
></TR
><TR
><TD
>Open an RPC Pipe with the name "\\PIPE\\lsarpc".  Store the file handle.</TD
></TR
><TR
><TD
>Using the file handle, send a Set Named Pipe Handle state to 0x4300.</TD
></TR
><TR
><TD
>Send an LSA Open Policy request.  Store the Policy Handle.</TD
></TR
><TR
><TD
>Using the Policy Handle, send LSA Query Info Policy requests, etc.</TD
></TR
><TR
><TD
>Using the Policy Handle, send an LSA Close.</TD
></TR
><TR
><TD
>Close the IPC$ share.</TD
></TR
></TBODY
></TABLE
><P
></P
><P
>Defines for this pipe, identifying the query are:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>LSA Open Policy:</DT
><DD
><P
>0x2c</P
></DD
><DT
>LSA Query Info Policy:</DT
><DD
><P
>0x07</P
></DD
><DT
>LSA Enumerate Trusted Domains:</DT
><DD
><P
>0x0d</P
></DD
><DT
>LSA Open Secret:</DT
><DD
><P
>0xff</P
></DD
><DT
>LSA Lookup SIDs:</DT
><DD
><P
>0xfe</P
></DD
><DT
>LSA Lookup Names:</DT
><DD
><P
>0xfd</P
></DD
><DT
>LSA Close:</DT
><DD
><P
>0x00</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1939"
></A
>9.3.6. LSA Open Policy</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	The policy handle can be anything you like.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1943"
></A
>9.3.6.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>buffer pointer</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>server name - unicode string starting with two '\'s</P
></DD
><DT
>OBJ_ATTR</DT
><DD
><P
>object attributes</P
></DD
><DT
>UINT32</DT
><DD
><P
>1 - desired access</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1962"
></A
>9.3.6.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>POL_HND</DT
><DD
><P
>LSA policy handle</P
></DD
><DT
>return</DT
><DD
><P
>0 - indicates success</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1973"
></A
>9.3.7. LSA Query Info Policy</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	The info class in response must be the same as that in the request.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1977"
></A
>9.3.7.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>POL_HND</DT
><DD
><P
>LSA policy handle</P
></DD
><DT
>UINT16</DT
><DD
><P
>info class (also a policy handle?)</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1988"
></A
>9.3.7.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>UINT16</DT
><DD
><P
>info class (same as info class in request).</P
></DD
></DL
></DIV
><P
><PRE
CLASS="PROGRAMLISTING"
>switch (info class)
case 3:
case 5:
{
DOM_INFO domain info, levels 3 and 5 (are the same).
}

return    0 - indicates success</PRE
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2001"
></A
>9.3.8. LSA Enumerate Trusted Domains</H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2003"
></A
>9.3.8.1. Request</H4
><P
>no extra data</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2006"
></A
>9.3.8.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>0 - enumeration context</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - entries read</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - trust information</P
></DD
><DT
>return</DT
><DD
><P
>0x8000 001a - "no trusted domains" success code</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2025"
></A
>9.3.9. LSA Open Secret</H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2027"
></A
>9.3.9.1. Request</H4
><P
>no extra data</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2030"
></A
>9.3.9.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>0 - undocumented</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - undocumented</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - undocumented</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - undocumented</P
></DD
><DT
>UINT32</DT
><DD
><P
>0 - undocumented</P
></DD
></DL
></DIV
><P
>return    0x0C00 0034 - "no such secret" success code</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2054"
></A
>9.3.10. LSA Close</H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2056"
></A
>9.3.10.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>POL_HND</DT
><DD
><P
>policy handle to be closed</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2063"
></A
>9.3.10.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>POL_HND</DT
><DD
><P
>0s - closed policy handle (all zeros)</P
></DD
></DL
></DIV
><P
>return    0 - indicates success</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2071"
></A
>9.3.11. LSA Lookup SIDS</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	num_entries in response must be same as num_entries in request.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2075"
></A
>9.3.11.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>POL_HND</DT
><DD
><P
>LSA policy handle</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented domain SID buffer pointer</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented domain name buffer pointer</P
></DD
><DT
>VOID*[num_entries] undocumented domain SID pointers to be looked up.</DT
><DD
><P
>DOM_SID[num_entries] domain SIDs to be looked up.</P
></DD
><DT
>char[16]</DT
><DD
><P
>completely undocumented 16 bytes.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2102"
></A
>9.3.11.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>DOM_REF</DT
><DD
><P
>domain reference response</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries (listed above)</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries (listed above)</P
></DD
><DT
>DOM_SID2[num_entries]</DT
><DD
><P
>domain SIDs (from Request, listed above).</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries (listed above)</P
></DD
></DL
></DIV
><P
>return                0 - indicates success</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2130"
></A
>9.3.12. LSA Lookup Names</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	num_entries in response must be same as num_entries in request.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2134"
></A
>9.3.12.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>POL_HND</DT
><DD
><P
>LSA policy handle</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented domain SID buffer pointer</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented domain name buffer pointer</P
></DD
><DT
>NAME[num_entries]</DT
><DD
><P
>names to be looked up.</P
></DD
><DT
>char[]</DT
><DD
><P
>undocumented bytes - falsely translated SID structure?</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2165"
></A
>9.3.12.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>DOM_REF</DT
><DD
><P
>domain reference response</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries (listed above)</P
></DD
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries (listed above)</P
></DD
><DT
>DOM_RID[num_entries]</DT
><DD
><P
>domain SIDs (from Request, listed above).</P
></DD
><DT
>UINT32</DT
><DD
><P
>num_entries (listed above)</P
></DD
></DL
></DIV
><P
>return                0 - indicates success</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2193"
></A
>9.4. NETLOGON rpc Transact Named Pipe</H2
><P
>The sequence of actions taken on this pipe are:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>tablish a connection to the IPC$ share (SMBtconX).  use encrypted passwords.</TD
></TR
><TR
><TD
>en an RPC Pipe with the name "\\PIPE\\NETLOGON".  Store the file handle.</TD
></TR
><TR
><TD
>ing the file handle, send a Set Named Pipe Handle state to 0x4300.</TD
></TR
><TR
><TD
>eate Client Challenge. Send LSA Request Challenge.  Store Server Challenge.</TD
></TR
><TR
><TD
>lculate Session Key.  Send an LSA Auth 2 Challenge.  Store Auth2 Challenge.</TD
></TR
><TR
><TD
>lc/Verify Client Creds.  Send LSA Srv PW Set.  Calc/Verify Server Creds.</TD
></TR
><TR
><TD
>lc/Verify Client Creds.  Send LSA SAM Logon .  Calc/Verify Server Creds.</TD
></TR
><TR
><TD
>lc/Verify Client Creds.  Send LSA SAM Logoff.  Calc/Verify Server Creds.</TD
></TR
><TR
><TD
>ose the IPC$ share.</TD
></TR
></TBODY
></TABLE
><P
></P
><P
>Defines for this pipe, identifying the query are</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>LSA Request Challenge:</DT
><DD
><P
>0x04</P
></DD
><DT
>LSA Server Password Set:</DT
><DD
><P
>0x06</P
></DD
><DT
>LSA SAM Logon:</DT
><DD
><P
>0x02</P
></DD
><DT
>LSA SAM Logoff:</DT
><DD
><P
>0x03</P
></DD
><DT
>LSA Auth 2:</DT
><DD
><P
>0x0f</P
></DD
><DT
>LSA Logon Control:</DT
><DD
><P
>0x0e</P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2232"
></A
>9.4.1. LSA Request Challenge</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	logon server name starts with two '\' characters and is upper case.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	logon client is the machine, not the user.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	the initial LanManager password hash, against which the challenge is issued, is the machine name itself (lower case).  there will becalls issued (LSA Server Password Set) which will change this, later. refusing these calls allows you to always deal with the same password (i.e the LM# of the machine name in lower case).</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2240"
></A
>9.4.1.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon server unicode string</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>logon client unicode string</P
></DD
><DT
>char[8]</DT
><DD
><P
>client challenge</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2259"
></A
>9.4.1.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>char[8]</DT
><DD
><P
>server challenge</P
></DD
></DL
></DIV
><P
>return    0 - indicates success</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2267"
></A
>9.4.2. LSA Authenticate 2</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	in between request and response, calculate the client credentials, and check them against the client-calculated credentials (this process uses the previously received client credentials).</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	neg_flags in the response is the same as that in the request.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	you must take a copy of the client-calculated credentials received 	here, because they will be used in subsequent authentication packets.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2275"
></A
>9.4.2.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>LOG_INFO</DT
><DD
><P
>client identification info</P
></DD
><DT
>char[8]</DT
><DD
><P
>client-calculated credentials</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>padding to 4-byte align with start of SMB header.</P
></DD
><DT
>UINT32</DT
><DD
><P
>neg_flags - negotiated flags (usual value is 0x0000 01ff)</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2294"
></A
>9.4.2.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>char[8]</DT
><DD
><P
>server credentials.</P
></DD
><DT
>UINT32</DT
><DD
><P
>neg_flags - same as neg_flags in request.</P
></DD
></DL
></DIV
><P
>return    0 - indicates success.  failure value unknown.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2306"
></A
>9.4.3. LSA Server Password Set</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: the new password is suspected to be a DES encryption using the old password to generate the key.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: in between request and response, calculate the client credentials, and check them against the client-calculated credentials (this process uses the previously received client credentials).</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: the server credentials are constructed from the client-calculated credentials and the client time + 1 second.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: you must take a copy of the client-calculated credentials received here, because they will be used in subsequent authentication packets.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2316"
></A
>9.4.3.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>CLNT_INFO</DT
><DD
><P
>client identification/authentication info</P
></DD
><DT
>char[]</DT
><DD
><P
>new password - undocumented.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2327"
></A
>9.4.3.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>CREDS</DT
><DD
><P
>server credentials.  server time stamp appears to be ignored.</P
></DD
></DL
></DIV
><P
>return    0 - indicates success; 0xC000 006a indicates failure</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2335"
></A
>9.4.4. LSA SAM Logon</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	valid_user is True iff the username and password hash are valid for
	the requested domain.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2339"
></A
>9.4.4.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>SAM_INFO</DT
><DD
><P
>sam_id structure</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2346"
></A
>9.4.4.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>CREDS</DT
><DD
><P
>server credentials.  server time stamp appears to be ignored.</P
></DD
></DL
></DIV
><P
><PRE
CLASS="PROGRAMLISTING"
>if (valid_user)
{
	UINT16      3 - switch value indicating USER_INFO structure.
    VOID*     non-zero - pointer to USER_INFO structure
    USER_INFO user logon information

    UINT32    1 - Authoritative response; 0 - Non-Auth?

    return    0 - indicates success
}
else
{
	UINT16    0 - switch value.  value to indicate no user presumed.
    VOID*     0x0000 0000 - indicates no USER_INFO structure.

    UINT32    1 - Authoritative response; 0 - Non-Auth?

    return    0xC000 0064 - NT_STATUS_NO_SUCH_USER.
}</PRE
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2359"
></A
>9.4.5. LSA SAM Logoff</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	presumably, the SAM_INFO structure is validated, and a (currently
	undocumented) error code returned if the Logoff is invalid.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2363"
></A
>9.4.5.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>SAM_INFO</DT
><DD
><P
>sam_id structure</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2370"
></A
>9.4.5.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>undocumented buffer pointer</P
></DD
><DT
>CREDS</DT
><DD
><P
>server credentials.  server time stamp appears to be ignored.</P
></DD
></DL
></DIV
><P
>return      0 - indicates success.  undocumented failure indication.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2382"
></A
>9.5. \\MAILSLOT\NET\NTLOGON</H2
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	mailslots will contain a response mailslot, to which the response
	should be sent.  the target NetBIOS name is REQUEST_NAME&#60;20&#62;, where
	REQUEST_NAME is the name of the machine that sent the request.</I
></SPAN
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2386"
></A
>9.5.1. Query for PDC</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	NTversion, LMNTtoken, LM20token in response are the same as those 	given in the request.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2390"
></A
>9.5.1.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16</DT
><DD
><P
>0x0007 - Query for PDC</P
></DD
><DT
>STR</DT
><DD
><P
>machine name</P
></DD
><DT
>STR</DT
><DD
><P
>response mailslot</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>padding to 2-byte align with start of mailslot.</P
></DD
><DT
>UNISTR</DT
><DD
><P
>machine name</P
></DD
><DT
>UINT32</DT
><DD
><P
>NTversion</P
></DD
><DT
>UINT16</DT
><DD
><P
>LMNTtoken</P
></DD
><DT
>UINT16</DT
><DD
><P
>LM20token</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2425"
></A
>9.5.1.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16</DT
><DD
><P
>0x000A - Respose to Query for PDC</P
></DD
><DT
>STR</DT
><DD
><P
>machine name (in uppercase)</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>padding to 2-byte align with start of mailslot.</P
></DD
><DT
>UNISTR</DT
><DD
><P
>machine name</P
></DD
><DT
>UNISTR</DT
><DD
><P
>domain name</P
></DD
><DT
>UINT32</DT
><DD
><P
>NTversion (same as received in request)</P
></DD
><DT
>UINT16</DT
><DD
><P
>LMNTtoken (same as received in request)</P
></DD
><DT
>UINT16</DT
><DD
><P
>LM20token (same as received in request)</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2460"
></A
>9.5.2. SAM Logon</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note: machine name in response is preceded by two '\' characters.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	NTversion, LMNTtoken, LM20token in response are the same as those given in the request.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	user name in the response is presumably the same as that in the request.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2468"
></A
>9.5.2.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16</DT
><DD
><P
>0x0012 - SAM Logon</P
></DD
><DT
>UINT16</DT
><DD
><P
>request count</P
></DD
><DT
>UNISTR</DT
><DD
><P
>machine name</P
></DD
><DT
>UNISTR</DT
><DD
><P
>user name</P
></DD
><DT
>STR</DT
><DD
><P
>response mailslot</P
></DD
><DT
>UINT32</DT
><DD
><P
>alloweable account</P
></DD
><DT
>UINT32</DT
><DD
><P
>domain SID size</P
></DD
><DT
>char[sid_size]</DT
><DD
><P
>domain SID, of sid_size bytes.</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>???? padding to 4? 2? -byte align with start of mailslot.</P
></DD
><DT
>UINT32</DT
><DD
><P
>NTversion</P
></DD
><DT
>UINT16</DT
><DD
><P
>LMNTtoken</P
></DD
><DT
>UINT16</DT
><DD
><P
>LM20token</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2519"
></A
>9.5.2.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT16</DT
><DD
><P
>0x0013 - Response to SAM Logon</P
></DD
><DT
>UNISTR</DT
><DD
><P
>machine name</P
></DD
><DT
>UNISTR</DT
><DD
><P
>user name - workstation trust account</P
></DD
><DT
>UNISTR</DT
><DD
><P
>domain name </P
></DD
><DT
>UINT32</DT
><DD
><P
>NTversion</P
></DD
><DT
>UINT16</DT
><DD
><P
>LMNTtoken</P
></DD
><DT
>UINT16</DT
><DD
><P
>LM20token</P
></DD
></DL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2550"
></A
>9.6. SRVSVC Transact Named Pipe</H2
><P
>Defines for this pipe, identifying the query are:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Net Share Enum</DT
><DD
><P
>0x0f</P
></DD
><DT
>Net Server Get Info</DT
><DD
><P
>0x15</P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2562"
></A
>9.6.1. Net Share Enum</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	share level and switch value in the response are presumably the same as those in the request.</I
></SPAN
></P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	cifsrap2.txt (section 5) may be of limited assistance here.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2568"
></A
>9.6.1.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>VOID*</DT
><DD
><P
>pointer (to server name?)</P
></DD
><DT
>UNISTR2</DT
><DD
><P
>server name</P
></DD
><DT
>UINT8[]</DT
><DD
><P
>padding to get unicode string 4-byte aligned with the start of the SMB header.</P
></DD
><DT
>UINT32</DT
><DD
><P
>share level</P
></DD
><DT
>UINT32</DT
><DD
><P
>switch value</P
></DD
><DT
>VOID*</DT
><DD
><P
>pointer to SHARE_INFO_1_CTR</P
></DD
><DT
>SHARE_INFO_1_CTR</DT
><DD
><P
>share info with 0 entries</P
></DD
><DT
>UINT32</DT
><DD
><P
>preferred maximum length (0xffff ffff)</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2603"
></A
>9.6.1.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>share level</P
></DD
><DT
>UINT32</DT
><DD
><P
>switch value</P
></DD
><DT
>VOID*</DT
><DD
><P
>pointer to SHARE_INFO_1_CTR</P
></DD
><DT
>SHARE_INFO_1_CTR</DT
><DD
><P
>share info (only added if share info ptr is non-zero)</P
></DD
></DL
></DIV
><P
>return            0 - indicates success</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2623"
></A
>9.6.2. Net Server Get Info</H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note:	level is the same value as in the request.</I
></SPAN
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2627"
></A
>9.6.2.1. Request</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UNISTR2</DT
><DD
><P
>server name</P
></DD
><DT
>UINT32</DT
><DD
><P
>switch level</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2638"
></A
>9.6.2.2. Response</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>UINT32</DT
><DD
><P
>switch level</P
></DD
><DT
>VOID*</DT
><DD
><P
>pointer to SERVER_INFO_101</P
></DD
><DT
>SERVER_INFO_101</DT
><DD
><P
>server info (only added if server info ptr is non-zero)</P
></DD
></DL
></DIV
><P
>return            0 - indicates success</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2654"
></A
>9.7. Cryptographic side of NT Domain Authentication</H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN2656"
></A
>9.7.1. Definitions</H3
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Add(A1,A2)</DT
><DD
><P
>Intel byte ordered addition of corresponding 4 byte words in arrays A1 and A2</P
></DD
><DT
>E(K,D)</DT
><DD
><P
>DES ECB encryption of 8 byte data D using 7 byte key K</P
></DD
><DT
>lmowf()</DT
><DD
><P
>Lan man hash</P
></DD
><DT
>ntowf()</DT
><DD
><P
>NT hash</P
></DD
><DT
>PW</DT
><DD
><P
>md4(machine_password) == md4(lsadump $machine.acc) ==
pwdump(machine$) (initially) == md4(lmowf(unicode(machine)))</P
></DD
><DT
>ARC4(K,Lk,D,Ld)</DT
><DD
><P
>ARC4 encryption of data D of length Ld with key K of length Lk</P
></DD
><DT
>v[m..n(,l)]</DT
><DD
><P
>subset of v from bytes m to n, optionally padded with zeroes to length l</P
></DD
><DT
>Cred(K,D)</DT
><DD
><P
>E(K[7..7,7],E(K[0..6],D)) computes a credential</P
></DD
><DT
>Time()</DT
><DD
><P
>4 byte current time</P
></DD
><DT
>Cc,Cs</DT
><DD
><P
>8 byte client and server challenges Rc,Rs: 8 byte client and server credentials</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2699"
></A
>9.7.2. Protocol</H3
><P
>C-&#62;S ReqChal,Cc S-&#62;C Cs</P
><P
>C &#38; S compute session key Ks = E(PW[9..15],E(PW[0..6],Add(Cc,Cs)))</P
><P
>C: Rc = Cred(Ks,Cc) C-&#62;S Authenticate,Rc S: Rs = Cred(Ks,Cs),
assert(Rc == Cred(Ks,Cc)) S-&#62;C Rs C: assert(Rs == Cred(Ks,Cs))</P
><P
>On joining the domain the client will optionally attempt to change its
password and the domain controller may refuse to update it depending
on registry settings. This will also occur weekly afterwards.</P
><P
>C: Tc = Time(), Rc' = Cred(Ks,Rc+Tc) C-&#62;S ServerPasswordSet,Rc',Tc,
arc4(Ks[0..7,16],lmowf(randompassword()) C: Rc = Cred(Ks,Rc+Tc+1) S:
assert(Rc' == Cred(Ks,Rc+Tc)), Ts = Time() S: Rs' = Cred(Ks,Rs+Tc+1)
S-&#62;C Rs',Ts C: assert(Rs' == Cred(Ks,Rs+Tc+1)) S: Rs = Rs'</P
><P
>User: U with password P wishes to login to the domain (incidental data
such as workstation and domain omitted)</P
><P
>C: Tc = Time(), Rc' = Cred(Ks,Rc+Tc) C-&#62;S NetLogonSamLogon,Rc',Tc,U,
arc4(Ks[0..7,16],16,ntowf(P),16), arc4(Ks[0..7,16],16,lmowf(P),16) S:
assert(Rc' == Cred(Ks,Rc+Tc)) assert(passwords match those in SAM) S:
Ts = Time()</P
><P
>S-&#62;C Cred(Ks,Cred(Ks,Rc+Tc+1)),userinfo(logon script,UID,SIDs,etc) C:
assert(Rs == Cred(Ks,Cred(Rc+Tc+1)) C: Rc = Cred(Ks,Rc+Tc+1)</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2709"
></A
>9.7.3. Comments</H3
><P
>On first joining the domain the session key could be computed by
anyone listening in on the network as the machine password has a well
known value. Until the machine is rebooted it will use this session
key to encrypt NT and LM one way functions of passwords which are
password equivalents. Any user who logs in before the machine has been
rebooted a second time will have their password equivalent exposed. Of
course the new machine password is exposed at this time anyway.</P
><P
>None of the returned user info such as logon script, profile path and
SIDs *appear* to be protected by anything other than the TCP checksum.</P
><P
>The server time stamps appear to be ignored.</P
><P
>The client sends a ReturnAuthenticator in the SamLogon request which I
can't find a use for.  However its time is used as the timestamp
returned by the server.</P
><P
>The password OWFs should NOT be sent over the network reversibly
encrypted. They should be sent using ARC4(Ks,md4(owf)) with the server
computing the same function using the owf values in the SAM.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2716"
></A
>9.8. SIDs and RIDs</H2
><P
>SIDs and RIDs are well documented elsewhere.</P
><P
>A SID is an NT Security ID (see DOM_SID structure).  They are of the form:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>revision-NN-SubAuth1-SubAuth2-SubAuth3... </TD
></TR
><TR
><TD
>revision-0xNNNNNNNNNNNN-SubAuth1-SubAuth2-SubAuth3...</TD
></TR
></TBODY
></TABLE
><P
></P
><P
>currently, the SID revision is 1.
The Sub-Authorities are known as Relative IDs (RIDs).</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2724"
></A
>9.8.1. Well-known SIDs</H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2726"
></A
>9.8.1.1. Universal well-known SIDs</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Null SID</DT
><DD
><P
>S-1-0-0</P
></DD
><DT
>World</DT
><DD
><P
>S-1-1-0</P
></DD
><DT
>Local</DT
><DD
><P
>S-1-2-0</P
></DD
><DT
>Creator Owner ID</DT
><DD
><P
>S-1-3-0</P
></DD
><DT
>Creator Group ID</DT
><DD
><P
>S-1-3-1</P
></DD
><DT
>Creator Owner Server ID</DT
><DD
><P
>S-1-3-2</P
></DD
><DT
>Creator Group Server ID</DT
><DD
><P
>S-1-3-3</P
></DD
><DT
>(Non-unique IDs)</DT
><DD
><P
>S-1-4</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2761"
></A
>9.8.1.2. NT well-known SIDs</H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>NT Authority</DT
><DD
><P
>S-1-5</P
></DD
><DT
>Dialup</DT
><DD
><P
>S-1-5-1</P
></DD
><DT
>Network</DT
><DD
><P
>S-1-5-2</P
></DD
><DT
>Batch</DT
><DD
><P
>S-1-5-3</P
></DD
><DT
>Interactive</DT
><DD
><P
>S-1-5-4</P
></DD
><DT
>Service</DT
><DD
><P
>S-1-5-6</P
></DD
><DT
>AnonymousLogon(aka null logon session)</DT
><DD
><P
>S-1-5-7</P
></DD
><DT
>Proxy</DT
><DD
><P
>S-1-5-8</P
></DD
><DT
>ServerLogon(aka domain controller account)</DT
><DD
><P
>S-1-5-8</P
></DD
><DT
>(Logon IDs)</DT
><DD
><P
>S-1-5-5-X-Y</P
></DD
><DT
>(NT non-unique IDs)</DT
><DD
><P
>S-1-5-0x15-...</P
></DD
><DT
>(Built-in domain)</DT
><DD
><P
>s-1-5-0x20</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2812"
></A
>9.8.2. Well-known RIDS</H3
><P
>A RID is a sub-authority value, as part of either a SID, or in the case
of Group RIDs, part of the DOM_GID structure, in the USER_INFO_1
structure, in the LSA SAM Logon response.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2815"
></A
>9.8.2.1. Well-known RID users</H4
><P
><B
>Groupname: </B
>DOMAIN_USER_RID_ADMIN</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>01F4</P
><P
><B
>Groupname: </B
>DOMAIN_USER_RID_GUEST</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>01F5</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2829"
></A
>9.8.2.2. Well-known RID groups</H4
><P
><B
>Groupname: </B
>	DOMAIN_GROUP_RID_ADMINS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0200</P
><P
><B
>Groupname: </B
>	DOMAIN_GROUP_RID_USERS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0201</P
><P
><B
>Groupname: </B
>	DOMAIN_GROUP_RID_GUESTS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0202</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2847"
></A
>9.8.2.3. Well-known RID aliases</H4
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_ADMINS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0220</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_USERS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0221</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_GUESTS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0222</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_POWER_USERS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0223</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_ACCOUNT_OPS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0224</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_SYSTEM_OPS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0225</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_PRINT_OPS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0226</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_BACKUP_OPS</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0227</P
><P
><B
>Groupname: </B
>	DOMAIN_ALIAS_RID_REPLICATOR</P
><P
><B
>????: </B
>0x0000</P
><P
><B
>RID: </B
>0228</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PRINTING"
></A
>Chapter 10. Samba Printing Internals</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN2896"
></A
>10.1. Abstract</H2
><P
>The purpose of this document is to provide some insight into
Samba's printing functionality and also to describe the semantics
of certain features of Windows client printing.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2899"
></A
>10.2. Printing Interface to Various Back ends</H2
><P
>Samba uses a table of function pointers to seven functions.  The
function prototypes are defined in the <TT
CLASS="VARNAME"
>printif</TT
> structure declared
in <TT
CLASS="FILENAME"
>printing.h</TT
>.</P
><P
></P
><UL
><LI
><P
>retrieve the contents of a print queue</P
></LI
><LI
><P
>pause the print queue</P
></LI
><LI
><P
>resume a paused print queue</P
></LI
><LI
><P
>delete a job from the queue</P
></LI
><LI
><P
>pause a job in the print queue</P
></LI
><LI
><P
>result a paused print job in the queue</P
></LI
><LI
><P
>submit a job to the print queue</P
></LI
></UL
><P
>Currently there are only two printing back end implementations
defined.</P
><P
></P
><UL
><LI
><P
>a generic set of functions for working with standard UNIX
	printing subsystems</P
></LI
><LI
><P
>a set of CUPS specific functions (this is only enabled if
	the CUPS libraries were located at compile time).</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2925"
></A
>10.3. Print Queue TDB's</H2
><P
>Samba provides periodic caching of the output from the "lpq command"
for performance reasons.  This cache time is configurable in seconds.
Obviously the longer the cache time the less often smbd will be
required to exec a copy of lpq.  However, the accuracy of the print
queue contents displayed to clients will be diminished as well.</P
><P
>The list of currently opened print queue TDB's can be found
be examining the list of tdb_print_db structures ( see print_db_head
in printing.c ). A queue TDB is opened using the wrapper function
printing.c:get_print_db_byname().  The function ensures that smbd
does not open more than MAX_PRINT_DBS_OPEN in an effort to prevent
a large print server from exhausting all available file descriptors.
If the number of open queue TDB's exceeds the MAX_PRINT_DBS_OPEN
limit, smbd falls back to a most recently used algorithm for maintaining
a list of open TDB's.</P
><P
>There are two ways in which a a print job can be entered into
a print queue's TDB.  The first is to submit the job from a Windows
client which will insert the job information directly into the TDB.
The second method is to have the print job picked up by executing the
"lpq command".</P
><P
><PRE
CLASS="PROGRAMLISTING"
>/* included from printing.h */
struct printjob {
	pid_t pid; /* which process launched the job */
	int sysjob; /* the system (lp) job number */
	int fd; /* file descriptor of open file if open */
	time_t starttime; /* when the job started spooling */
	int status; /* the status of this job */
	size_t size; /* the size of the job so far */
	int page_count;	/* then number of pages so far */
	BOOL spooled; /* has it been sent to the spooler yet? */
	BOOL smbjob; /* set if the job is a SMB job */
	fstring filename; /* the filename used to spool the file */
	fstring jobname; /* the job name given to us by the client */
	fstring user; /* the user who started the job */
	fstring queuename; /* service number of printer for this job */
	NT_DEVICEMODE *nt_devmode;
};</PRE
></P
><P
>The current manifestation of the printjob structure contains a field
for the UNIX job id returned from the "lpq command" and a Windows job
ID (32-bit bounded by PRINT_MAX_JOBID).  When a print job is returned
by the "lpq command" that does not match an existing job in the queue's
TDB, a 32-bit job ID above the &lt;*vance doesn't know what word is missing here*&gt; is generating by adding UNIX_JOB_START to
the id reported by lpq.</P
><P
>In order to match a 32-bit Windows jobid onto a 16-bit lanman print job
id, smbd uses an in memory TDB to match the former to a number appropriate
for old lanman clients.</P
><P
>When updating a print queue, smbd will perform the following
steps ( refer to <TT
CLASS="FILENAME"
>print.c:print_queue_update()</TT
> ):</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Check to see if another smbd is currently in 
	the process of updating the queue contents by checking the pid 
	stored in <TT
CLASS="CONSTANT"
>LOCK/<TT
CLASS="REPLACEABLE"
><I
>printer_name</I
></TT
></TT
>.  
	If so, then do not update the TDB.</P
></LI
><LI
><P
>Lock the mutex entry in the TDB and store our own pid.
	Check that this succeeded, else fail.</P
></LI
><LI
><P
>Store the updated time stamp for the new cache
	listing</P
></LI
><LI
><P
>Retrieve the queue listing via "lpq command"</P
></LI
><LI
><P
><PRE
CLASS="PROGRAMLISTING"
>	foreach job in the queue
     	{
		if the job is a UNIX job, create a new entry;
		if the job has a Windows based jobid, then
		{
			Lookup the record by the jobid;
			if the lookup failed, then
				treat it as a UNIX job;
			else
				update the job status only
		}
	}</PRE
></P
></LI
><LI
><P
>Delete any jobs in the TDB that are not
	in the in the lpq listing</P
></LI
><LI
><P
>Store the print queue status in the TDB</P
></LI
><LI
><P
>update the cache time stamp again</P
></LI
></OL
><P
>Note that it is the contents of this TDB that is returned to Windows
clients and not the actual listing from the "lpq command".</P
><P
>The NT_DEVICEMODE stored as part of the printjob structure is used to
store a pointer to a non-default DeviceMode associated with the print
job.  The pointer will be non-null when the client included a Device
Mode in the OpenPrinterEx() call and subsequently submitted a job for
printing on that same handle.  If the client did not include a Device
Mode in the OpenPrinterEx() request, the nt_devmode field is NULL
and the job has the printer's device mode associated with it by default.</P
><P
>Only non-default Device Mode are stored with print jobs in the print
queue TDB.  Otherwise, the Device Mode is obtained from the printer
object when the client issues a GetJob(level == 2) request.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2959"
></A
>10.4. ChangeID &#38; Client Caching of Printer Information</H2
><P
>[To be filled in later]</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2962"
></A
>10.5. Windows NT/2K Printer Change Notify</H2
><P
>When working with Windows NT+ clients, it is possible for a
print server to use RPC to send asynchronous change notification
events to clients for certain printer and print job attributes.
This can be useful when the client needs to know that a new
job has been added to the queue for a given printer or that the
driver for a printer has been changed.  Note that this is done
entirely orthogonal to cache updates based on a new ChangeID for
a printer object.</P
><P
>The basic set of RPC's used to implement change notification are</P
><P
></P
><UL
><LI
><P
>RemoteFindFirstPrinterChangeNotifyEx ( RFFPCN )</P
></LI
><LI
><P
>RemoteFindNextPrinterChangeNotifyEx ( RFNPCN )</P
></LI
><LI
><P
>FindClosePrinterChangeNotify( FCPCN )</P
></LI
><LI
><P
>ReplyOpenPrinter</P
></LI
><LI
><P
>ReplyClosePrinter</P
></LI
><LI
><P
>RouteRefreshPrinterChangeNotify ( RRPCN )</P
></LI
></UL
><P
>One additional RPC is available to a server, but is never used by the
Windows spooler service:</P
><P
></P
><UL
><LI
><P
>RouteReplyPrinter()</P
></LI
></UL
><P
>The opnum for all of these RPC's are defined in include/rpc_spoolss.h</P
><P
>Windows NT print servers use a bizarre method of sending print
notification event to clients.  The process of registering a new change
notification handle is as follows.  The 'C' is for client and the
'S' is for server.  All error conditions have been eliminated.</P
><P
><PRE
CLASS="PROGRAMLISTING"
>C:	Obtain handle to printer or to the printer
	server via the standard OpenPrinterEx() call.
S:	Respond with a valid handle to object

C:	Send a RFFPCN request with the previously obtained
	handle with either (a) set of flags for change events
	to monitor, or (b) a PRINTER_NOTIFY_OPTIONS structure
	containing the event information to monitor.  The windows
	spooler has only been observed to use (b).
S:	The &lt;* another missing word*&gt; opens a new TCP session to the client (thus requiring
	all print clients to be CIFS servers as well) and sends
	a ReplyOpenPrinter() request to the client.
C:	The client responds with a printer handle that can be used to
	send event notification messages.
S:	The server replies success to the RFFPCN request.

C:	The windows spooler follows the RFFPCN with a RFNPCN
	request to fetch the current values of all monitored
	attributes.
S:	The server replies with an array SPOOL_NOTIFY_INFO_DATA
	structures (contained in a SPOOL_NOTIFY_INFO structure).

C:	If the change notification handle is ever released by the
	client via a FCPCN request, the server sends a ReplyClosePrinter()
	request back to the client first.  However a request of this
	nature from the client is often an indication that the previous
	notification event was not marshalled correctly by the server
	or a piece of data was wrong.
S:	The server closes the internal change notification handle
	(POLICY_HND) and does not send any further change notification
	events to the client for that printer or job.</PRE
></P
><P
>The current list of notification events supported by Samba can be
found by examining the internal tables in srv_spoolss_nt.c</P
><P
></P
><UL
><LI
><P
>printer_notify_table[]</P
></LI
><LI
><P
>job_notify_table[]</P
></LI
></UL
><P
>When an event occurs that could be monitored, smbd sends a message
to itself about the change.  The list of events to be transmitted
are queued by the smbd process sending the message to prevent an
overload of TDB usage and the internal message is sent during smbd's
idle loop (refer to printing/notify.c and the functions
send_spoolss_notify2_msg() and print_notify_send_messages() ).</P
><P
>The decision of whether or not the change is to be sent to connected
clients is made by the routine which actually sends the notification.
( refer to srv_spoolss_nt.c:recieve_notify2_message() ).</P
><P
>Because it possible to receive a listing of multiple changes for
multiple printers, the notification events must be split into
categories by the printer name.  This makes it possible to group
multiple change events to be sent in a single RPC according to the
printer handle obtained via a ReplyOpenPrinter().</P
><P
>The actual change notification is performed using the RRPCN request
RPC.  This packet contains</P
><P
></P
><UL
><LI
><P
>the printer handle registered with the
client's spooler on which the change occurred</P
></LI
><LI
><P
>The change_low value which was sent as part
of the last RFNPCN request from the client</P
></LI
><LI
><P
>The SPOOL_NOTIFY_INFO container with the event
information</P
></LI
></UL
><P
>A <TT
CLASS="VARNAME"
>SPOOL_NOTIFY_INFO</TT
> contains:</P
><P
></P
><UL
><LI
><P
>the version and flags field are predefined
and should not be changed</P
></LI
><LI
><P
>The count field is the number of entries
in the SPOOL_NOTIFY_INFO_DATA array</P
></LI
></UL
><P
>The <TT
CLASS="VARNAME"
>SPOOL_NOTIFY_INFO_DATA</TT
> entries contain:</P
><P
></P
><UL
><LI
><P
>The type defines whether or not this event
is for a printer or a print job</P
></LI
><LI
><P
>The field is the flag identifying the event</P
></LI
><LI
><P
>the notify_data union contains the new valuie of the
attribute</P
></LI
><LI
><P
>The enc_type defines the size of the structure for marshalling
and unmarshalling</P
></LI
><LI
><P
>(a) the id must be 0 for a printer event on a printer handle.
(b) the id must be the job id for an event on a printer job
(c) the id must be the matching number of the printer index used
in the response packet to the RFNPCN when using a print server
handle for notification.  Samba currently uses the snum of
the printer for this which can break if the list of services
has been modified since the notification handle was registered.</P
></LI
><LI
><P
>The size is either (a) the string length in UNICODE for strings,
(b) the size in bytes of the security descriptor, or (c) 0 for
data values.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="WINS"
></A
>Chapter 11. Samba WINS Internals</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN3033"
></A
>11.1. WINS Failover</H2
><P
>The current Samba codebase possesses the capability to use groups of WINS
servers that share a common namespace for NetBIOS name registration and 
resolution.  The formal parameter syntax is</P
><P
><PRE
CLASS="PROGRAMLISTING"
>	WINS_SERVER_PARAM 	= SERVER [ SEPARATOR SERVER_LIST ]
	WINS_SERVER_PARAM 	= &quot;wins server&quot;
	SERVER 			= ADDR[:TAG]
	ADDR 			= ip_addr | fqdn
	TAG 			= string
	SEPARATOR		= comma | \s+
	SERVER_LIST		= SERVER [ SEPARATOR SERVER_LIST ]</PRE
></P
><P
>A simple example of a valid wins server setting is</P
><P
><PRE
CLASS="PROGRAMLISTING"
>[global]
	wins server = 192.168.1.2 192.168.1.3</PRE
></P
><P
>In the event that no TAG is defined in for a SERVER in the list, smbd assigns a default
TAG of &quot;*&quot;.  A TAG is used to group servers of a shared NetBIOS namespace together.  Upon
startup, nmbd will attempt to register the netbios name value with one server in each
tagged group.</P
><P
>An example using tags to group WINS servers together is show here.  Note that the use of
interface names in the tags is only by convention and is not a technical requirement.</P
><P
><PRE
CLASS="PROGRAMLISTING"
>[global]
	wins server = 192.168.1.2:eth0 192.168.1.3:eth0 192.168.2.2:eth1</PRE
></P
><P
>Using this configuration, nmbd would attempt to register the server's NetBIOS name 
with one WINS server in each group.  Because the &quot;eth0&quot; group has two servers, the 
second server would only be used when a registration (or resolution) request to 
the first server in that group timed out.</P
><P
>NetBIOS name resolution follows a similar pattern as name registration.  When resolving 
a NetBIOS name via WINS, smbd and other Samba programs will attempt to query a single WINS 
server in a tagged group until either a positive response is obtained at least once or 
until a server from every tagged group has responded negatively to the name query request.
If a timeout occurs when querying a specific WINS server, that server is marked as down to 
prevent further timeouts and the next server in the WINS group is contacted.  Once marked as 
dead, Samba will not attempt to contact that server for name registration/resolution queries 
for a period of 10 minutes.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SAM"
></A
>Chapter 12. The Upcoming SAM System</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN3054"
></A
>12.1. Security in the 'new SAM'</H2
><P
>One of the biggest problems with passdb is it's implementation of
'security'.  Access control is on a 'are you root at the moment' basis,
and it has no concept of NT ACLs.  Things like ldapsam had to add
'magic' 'are you root' checks.</P
><P
>We took this very seriously when we started work, and the new structure
is designed with this in mind, from the ground up.  Each call to the SAM
has a NT_TOKEN and (if relevant) an 'access desired'.  This is either
provided as a parameter, or implicitly supplied by the object being
accessed.</P
><P
>For example, when you call </P
><PRE
CLASS="PROGRAMLISTING"
>&#60;
NTSTATUS sam_get_account_by_name(const SAM_CONTEXT *context, const
NT_USER_TOKEN *access_token, uint32 access_desired, const char *domain,
const char *name, SAM_ACCOUNT_HANDLE **account)</PRE
><P
>The context can be NULL (and is used to allow import/export by setting
up 2 contexts, and allowing calls on both simultaneously)</P
><P
>The access token *must* be specified.  Normally the user's token out of
current_user, this can also be a global 'system' context.</P
><P
>The access desired is as per the ACL, for passing to the seaccess stuff.</P
><P
>The domain/username are standard.  Even if we only have one domain,
keeping this ensures that we don't get 'unqualified' usernames (same
problem as we had with unqualified SIDs).</P
><P
>We return a 'handle'.  This is opaque to the rest of Samba, but is
operated on by get/set routines, all of which return NTSTATUS.</P
><P
>The access checking is done by the SAM module.   The reason it is not
done 'above' the interface is to ensure a 'choke point'.  I put a lot of
effort into the auth subsystem to ensure we never 'accidentally' forgot
to check for null passwords, missed a restriction etc.  I intend the SAM
to be written with the same caution.</P
><P
>The reason the access checking is not handled by the interface itself is
due to the different implementations it make take on.  For example, on
ADS, you cannot set a password over a non-SSL connection.  Other
backends may have similar requirements - we need to leave this policy up
to the modules.  They will naturally have access to 'helper' procedures
and good examples to avoid mishaps.</P
><P
>(Furthermore, some backends my actually chose to push the whole ACL
issue to the remote server, and - assuming ldap for this example - bind
as the user directly)</P
><P
>Each returned handle has an internal 'access permitted', which allows
the 'get' and 'set' routines to return 'ACCESS_DENIED' for things that
were not able to be retrieved from the backend.  This removes the need
to specify the NT_TOKEN on every operation, and allows for 'object not
present' to be easily distinguished from 'access denied'.</P
><P
>When you 'set' an object (calling sam_update_account) the internal
details are again used.  Each change that has been made to the object
has been flagged, so as to avoid race conditions (on unmodified
components) and to avoid violating any extra ACL requirements on the
actual data store (like the LDAP server).</P
><P
>Finally, we have generic get_sec_desc() and set_sec_desc() routines to
allow external ACL manipulation.  These do lookups based on SID.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3071"
></A
>12.2. Standalone from UNIX</H2
><P
>One of the primary tenants of the 'new SAM' is that it would not attempt
to deal with 'what unix id for that'.  This would be left to the 'SMS'
(Sid Mapping System') or SID farm, and probably administered via
winbind.  We have had constructive discussion on how 'basic' unix
accounts like 'root' would be handled, and we think this can work.  
Accounts not preexisting in unix would be served up via winbind.</P
><P
>This is an *optional* part, and my preferred end-game.  We have a fare
way to go before things like winbind up to it however.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3075"
></A
>12.3. Handles and Races in the new SAM</H2
><P
>One of the things that the 'new SAM' work has tried to face is both
compatibility with existing code, and a closer alignment to the SAMR
interface.  I consider SAMR to be a 'primary customer' to the this work,
because if we get alignment with that wrong, things get more, rather
than less complex.  Also, most other parts of Samba are much more
flexible with what they can allow.</P
><P
>In any case, that was a decision taken as to how the general design
would progress.  BTW, my understanding of SAMR may be completely flawed.</P
><P
>One of the most race-prone areas of the new code is the conflicting
update problem.  We have taken two approaches:  </P
><P
></P
><UL
><LI
><P
>'Not conflicting' conflicts.  Due to the way usrmgr operates, it will
open a user, display all the properties and *save* them all, even if you
don't change any.</P
><P
>For this, see what I've done in rpc_server/srv_samr_util.c.  I intend
to take this one step further, and operate on the 'handle' that the
values were read from.  This should mean that we only update things that
have *really* changed.</P
></LI
><LI
><P
>'conflicting' updates:  Currently we don't deal with this (in passdb
or the new sam stuff), but the design is sufficiently flexible to 'deny'
a second update.  I don't foresee locking records however.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3086"
></A
>12.4. Layers</H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN3088"
></A
>12.4.1. Application</H3
><P
>This is where smbd, samtest and whatever end-user replacement we have
for pdbedit sits.  They use only the SAM interface, and do not get
'special knowledge' of what is below them.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3091"
></A
>12.4.2. SAM Interface</H3
><P
>This level 'owns' the various handle structures, the get/set routines on
those structures and provides the public interface.  The application
layer may initialize a 'context' to be passed to all interface routines,
else a default, self-initialising context will be supplied.  This layser
finds the appropriate backend module for the task, and tries very hard
not to need to much 'knowledge'.  It should just provide the required
abstraction to the modules below, and arrange for their initial loading.</P
><P
>We could possibly add ACL checking at this layer, to avoid discrepancies
in implementation modules.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3095"
></A
>12.4.3. SAM Modules</H3
><P
>These do not communicate with the application directly, only by setting
values in the handles, and receiving requests from the interface.  These
modules are responsible for translating values from the handle's
.private into (say) an LDAP modification list.  The module is expected
to 'know' things like it's own domain SID, domain name, and any other
state attached to the SAM.  Simpler modules may call back to some helper
routine.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3098"
></A
>12.5. SAM Modules</H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN3100"
></A
>12.5.1. Special Module: sam_passdb</H3
><P
>In order for there to be a smooth transition, kai is writing a module
that reads existing passdb backends, and translates them into SAM
replies.  (Also pulling data from the account policy DB etc).  We also
intend to write a module that does the reverse - gives the SAM a passdb
interface.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3103"
></A
>12.5.2. sam_ads</H3
><P
>This is the first of the SAM modules to be committed to the tree -
mainly because I needed to coordinate work with metze (who authored most
of it).  This module aims to use Samba's libads code to provide an
Active Directory LDAP client, suitable for use on a mixed-mode DC. 
While it is currently being tested against Win2k servers (with a
password in the smb.conf file) it is expected to eventually use a
(possibly modified) OpenLDAP server.  We hope that this will assist in
the construction of an Samba AD DC.</P
><P
>We also intend to construct a Samba 2.2/3.0 compatible ldap module,
again using libads code.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3107"
></A
>12.6. Memory Management</H2
><P
> 
The 'new SAM' development effort also concerned itself with getting a
sane implementation of memory management.  It was decided that we would
be (as much as possible) talloc based, using an 'internal talloc
context' on many objects.  That is, the creation of an object would
initiate it's own internal talloc context, and this would be used for
all operations on that object.  Much of this is already implemented in
passdb.  Also, like passdb, it will be possible to specify that some
object actually be created on a specified context.  </P
><P
>Memory management is important here because the APIs in the 'new SAM' do
not use 'pdb_init()' or an equivalent.  They always allocate new
objects.  Enumeration's are slightly different, and occur on a supplied
context that 'owns' the entire list, rather than per-element.  (the
enumeration functions return an array of all elements - not full handles
just basic (and public) info)  Likewise for things that fill in a char
**.</P
><P
>For example:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>NTSTATUS sam_lookup_sid(const SAM_CONTEXT *context, const NT_USER_TOKEN
*access_token, TALLOC_CTX *mem_ctx, const DOM_SID *sid, char **name,
uint32 *type)</PRE
></P
><P
>Takes a context to allocate the 'name' on, while:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>NTSTATUS sam_get_account_by_sid(const SAM_CONTEXT *context, const
NT_USER_TOKEN *access_token, uint32 access_desired, const DOM_SID
*accountsid, SAM_ACCOUNT_HANDLE **account)</PRE
></P
><P
>Allocates a handle and stores the allocation context on that handle.</P
><P
>I think that the following:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>NTSTATUS sam_enum_accounts(const SAM_CONTEXT *context, const
NT_USER_TOKEN *access_token, const DOM_SID *domainsid, uint16 acct_ctrl,
int32 *account_count, SAM_ACCOUNT_ENUM **accounts)</PRE
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3121"
></A
>12.7. Testing</H2
><P
>Testing is vital in any piece of software, and Samba is certainly no
exception. In designing this new subsystem, we have taken care to ensure
it is easily tested, independent of outside protocols.</P
><P
>To this end, Jelmer has constructed 'samtest'.  </P
><P
>This utility (see torture/samtest.c) is structured like rpcclient, but
instead operates on the SAM subsystem.  It creates a 'custom' SAM
context, that may be distinct from the default values used by the rest
of the system, and can load a separate configuration file.  </P
><P
>A small number of commands are currently implemented, but these have
already proved vital in testing.   I expect SAM module authors will find
it particularly valuable.</P
><P
>Example useage:</P
><P
><TT
CLASS="PROMPT"
>$</TT
> <B
CLASS="COMMAND"
>bin/samtest</B
></P
><P
><PRE
CLASS="PROGRAMLISTING"
>&#62; context ads:ldap://192.168.1.96</PRE
>
(this loads a new context, using the new ADS module.  The parameter is
the 'location' of the ldap server)</P
><P
><PRE
CLASS="PROGRAMLISTING"
>&#62; lookup_name DOMAIN abartlet</PRE
>
(returns a sid).</P
><P
>Because the 'new SAM' is NT ACL based, there will be a command to
specify an arbitrary NT ACL, but for now it uses 'system' by default.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PWENCRYPT"
></A
>Chapter 13. LanMan and NT Password Encryption</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN3147"
></A
>13.1. Introduction</H2
><P
>With the development of LanManager and Windows NT 
	compatible password encryption for Samba, it is now able 
	to validate user connections in exactly the same way as 
	a LanManager or Windows NT server.</P
><P
>This document describes how the SMB password encryption 
	algorithm works and what issues there are in choosing whether 
	you want to use it. You should read it carefully, especially 
	the part about security and the "PROS and CONS" section.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3151"
></A
>13.2. How does it work?</H2
><P
>LanManager encryption is somewhat similar to UNIX 
	password encryption. The server uses a file containing a 
	hashed value of a user's password.  This is created by taking 
	the user's plaintext password, capitalising it, and either 
	truncating to 14 bytes or padding to 14 bytes with null bytes. 
	This 14 byte value is used as two 56 bit DES keys to encrypt 
	a 'magic' eight byte value, forming a 16 byte value which is 
	stored by the server and client. Let this value be known as 
	the "hashed password".</P
><P
>Windows NT encryption is a higher quality mechanism, 
	consisting of doing an MD4 hash on a Unicode version of the user's 
	password. This also produces a 16 byte hash value that is 
	non-reversible.</P
><P
>When a client (LanManager, Windows for WorkGroups, Windows 
	95 or Windows NT) wishes to mount a Samba drive (or use a Samba 
	resource), it first requests a connection and negotiates the 
	protocol that the client and server will use. In the reply to this 
	request the Samba server generates and appends an 8 byte, random 
	value - this is stored in the Samba server after the reply is sent 
	and is known as the "challenge".  The challenge is different for 
	every client connection.</P
><P
>The client then uses the hashed password (16 byte values 
	described above), appended with 5 null bytes, as three 56 bit 
	DES keys, each of which is used to encrypt the challenge 8 byte 
	value, forming a 24 byte value known as the "response".</P
><P
>In the SMB call SMBsessionsetupX (when user level security 
	is selected) or the call SMBtconX (when share level security is 
	selected), the 24 byte response is returned by the client to the 
	Samba server.  For Windows NT protocol levels the above calculation 
	is done on both hashes of the user's password and both responses are 
	returned in the SMB call, giving two 24 byte values.</P
><P
>The Samba server then reproduces the above calculation, using 
	its own stored value of the 16 byte hashed password (read from the 
	<TT
CLASS="FILENAME"
>smbpasswd</TT
> file - described later) and the challenge 
	value that it kept from the negotiate protocol reply. It then checks 
	to see if the 24 byte value it calculates matches the 24 byte value 
	returned to it from the client.</P
><P
>If these values match exactly, then the client knew the 
	correct password (or the 16 byte hashed value - see security note 
	below) and is thus allowed access. If not, then the client did not 
	know the correct password and is denied access.</P
><P
>Note that the Samba server never knows or stores the cleartext 
	of the user's password - just the 16 byte hashed values derived from 
	it. Also note that the cleartext password or 16 byte hashed values 
	are never transmitted over the network - thus increasing security.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3162"
></A
>13.3. <A
NAME="SMBPASSWDFILEFORMAT"
></A
>The smbpasswd file</H2
><P
>In order for Samba to participate in the above protocol 
	it must be able to look up the 16 byte hashed values given a user name.
	Unfortunately, as the UNIX password value is also a one way hash
	function (ie. it is impossible to retrieve the cleartext of the user's
	password given the UNIX hash of it), a separate password file
	containing this 16 byte value must be kept. To minimise problems with
	these two password files, getting out of sync, the UNIX <TT
CLASS="FILENAME"
>	/etc/passwd</TT
> and the <TT
CLASS="FILENAME"
>smbpasswd</TT
> file, 
	a utility, <B
CLASS="COMMAND"
>mksmbpasswd.sh</B
>, is provided to generate
	a smbpasswd file from a UNIX <TT
CLASS="FILENAME"
>/etc/passwd</TT
> file.
	</P
><P
>To generate the smbpasswd file from your <TT
CLASS="FILENAME"
>/etc/passwd
	</TT
> file use the following command :</P
><P
><TT
CLASS="PROMPT"
>$ </TT
><TT
CLASS="USERINPUT"
><B
>cat /etc/passwd | mksmbpasswd.sh
	&gt; /usr/local/samba/private/smbpasswd</B
></TT
></P
><P
>If you are running on a system that uses NIS, use</P
><P
><TT
CLASS="PROMPT"
>$ </TT
><TT
CLASS="USERINPUT"
><B
>ypcat passwd | mksmbpasswd.sh
	&gt; /usr/local/samba/private/smbpasswd</B
></TT
></P
><P
>The <B
CLASS="COMMAND"
>mksmbpasswd.sh</B
> program is found in 
	the Samba source directory. By default, the smbpasswd file is 
	stored in :</P
><P
><TT
CLASS="FILENAME"
>/usr/local/samba/private/smbpasswd</TT
></P
><P
>The owner of the <TT
CLASS="FILENAME"
>/usr/local/samba/private/</TT
> 
	directory should be set to root, and the permissions on it should 
	be set to 0500 (<B
CLASS="COMMAND"
>chmod 500 /usr/local/samba/private</B
>).
	</P
><P
>Likewise, the smbpasswd file inside the private directory should 
	be owned by root and the permissions on is should be set to 0600
	(<B
CLASS="COMMAND"
>chmod 600 smbpasswd</B
>).</P
><P
>The format of the smbpasswd file is (The line has been 
	wrapped here. It should appear as one entry per line in 
	your smbpasswd file.)</P
><P
><PRE
CLASS="PROGRAMLISTING"
>username:uid:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:
	[Account type]:LCT-&lt;last-change-time&gt;:Long name
	</PRE
></P
><P
>Although only the <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
>, 
	<TT
CLASS="REPLACEABLE"
><I
>uid</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</I
></TT
>,
	[<TT
CLASS="REPLACEABLE"
><I
>Account type</I
></TT
>] and <TT
CLASS="REPLACEABLE"
><I
>	last-change-time</I
></TT
> sections are significant 
	and are looked at in the Samba code.</P
><P
>It is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>VITALLY</I
></SPAN
> important that there by 32 
	'X' characters between the two ':' characters in the XXX sections - 
	the smbpasswd and Samba code will fail to validate any entries that 
	do not have 32 characters  between ':' characters. The first XXX 
	section is for the Lanman password hash, the second is for the 
	Windows NT version.</P
><P
>When the password file is created all users have password entries
	consisting of 32 'X' characters. By default this disallows any access
	as this user. When a user has a password set, the 'X' characters change
	to 32 ascii hexadecimal digits (0-9, A-F). These are an ascii
	representation of the 16 byte hashed value of a user's password.</P
><P
>To set a user to have no password (not recommended), edit the file
	using vi, and replace the first 11 characters with the ascii text
	<TT
CLASS="CONSTANT"
>"NO PASSWORD"</TT
> (minus the quotes).</P
><P
>For example, to clear the password for user bob, his smbpasswd file 
	entry would look like :</P
><P
><PRE
CLASS="PROGRAMLISTING"
>	bob:100:NO PASSWORDXXXXXXXXXXXXXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:[U          ]:LCT-00000000:Bob's full name:/bobhome:/bobshell
	</PRE
></P
><P
>If you are allowing users to use the smbpasswd command to set 
	their own passwords, you may want to give users NO PASSWORD initially 
	so they do not have to enter a previous password when changing to their 
	new password (not recommended). In order for you to allow this the
	<B
CLASS="COMMAND"
>smbpasswd</B
> program must be able to connect to the 
	<B
CLASS="COMMAND"
>smbd</B
> daemon as that user with no password. Enable this 
	by adding the line :</P
><P
><B
CLASS="COMMAND"
>null passwords = yes</B
></P
><P
>to the [global] section of the smb.conf file (this is why 
	the above scenario is not recommended). Preferably, allocate your
	users a default password to begin with, so you do not have
	to enable this on your server.</P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note : </I
></SPAN
>This file should be protected very 
	carefully. Anyone with access to this file can (with enough knowledge of 
	the protocols) gain access to your SMB server. The file is thus more 
	sensitive than a normal unix <TT
CLASS="FILENAME"
>/etc/passwd</TT
> file.</P
></DIV
></DIV
></DIV
></BODY
></HTML
>