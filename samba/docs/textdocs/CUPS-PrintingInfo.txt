There are Six (6) Extracts here from mail in the Samba Mailing List.
The key contribution here is from Kurt Pfeifle.

I added them to this repository in the hope that someone would find the information helpful.

John T. <jht@samba.org>

==============================================================================
<<< EXTANT 1 >>>
==============================================================================
Subject: Print Filtering Mechanism Explained
============================================

Date: Sun, 22 Sep 2002 15:38:02 +0200
From: "Kurt Pfeifle" <kpfeifle@danka.de>
Reply-To: kpfeifle@danka.de
Organization: Danka Deutschland GmbH
To: samba@lists.samba.org
Subject: CUPS filtering mechanism explained, was: [cups raw mode, was Re: [Samba] unlink data file in cups_job_submit]

Paul Janzen wrote on Samba digest:

 > Message: 7
 > To: Gerald Carter <jerry@samba.org>
 > Cc: samba@lists.samba.org
 > From: Paul Janzen <pcj@samba.sez.to>
 > Subject: cups raw mode, was Re: [Samba] unlink data file in cups_job_submit
 > Date: 21 Sep 2002 12:09:23 -0700
 >
 >
 > Gerald Carter <jerry@samba.org> writes:
 >
 >  > Looks right to me  [:-)] Applying it now.  Thanks.  I've been meaning to
 >  > track this one down.
 >
 >
 > Thanks!
 >
 > While we are on the subject...  [:-)]
 >
 > If I am using native printer drivers on Windows clients, I would like
 > the "raw" option to get propagated to CUPS.  Otherwise cups does not
 > pass the data on to the printer.

Paul,

I see you know about what you call the "raw data passthrough feature".
I guess you mean the lines in "/etc/cups/mime.types" and
"/etc/cups/mime.convs" which need to be uncommented to allow "raw"
printing ?

Here is some clarification (likely not very useful for you, but
possibly for some other readers of the Samba list):

###  If you have "printing = cups" and "printcap = cups" enabled,
---  everything is handled by Samba accessing the CUPS API. (And any
      "print command" directive in Samba will be ignored.) If the CUPS
      API is not available (because Samba might not be compiled against
libcups), it automatically maps to the "System V" command set, with
"-oraw" enabled automatically.

 > (If I enable cups's application/
 > octet-stream raw-data passthrough feature, both cupsomatic and the
 > Windows driver add PJL headers and footers, which is not what I want
 > either.)

###  According to my experience, cupsomatic on the Samba/CUPS server
---  does *not* add any features if a file is really printed "raw".
      However, if you have loaded the driver for the Windows client
from the CUPS server, using the "cupsaddsmb" utility, and if this
driver is one using a "Foomatic" PPD, the PJL header in question is
already added on the Windows client, at the time when the driver
initially generated the PostScript data -- and CUPS in true "-oraw"
manner doesn't remove this PJL header and passes the file "as is"
to its printer communication backend.

NOTE,  please, that the editing in the "mime.convs" and the
-----  "mime.types" file does not *enforce* "raw" printing, it
        only *allows* it. Any file arriving from Windows is
"auto-typed" by CUPS, which might consecutively lead to its
treatment by various filters automatically (depending on the
actual outcome of the auto-typing and the configuration of the
printqueue in question):

     --> Files generated by PCL drivers and destined to PCL
         printers get auto-typed "application/octet-stream"
         and are indeed printed "raw". Also, unknown file
         types are getting tagged as "application/octet-stream".

     --> Files generated by a PostScript driver (and destined
         for any target printer type) are auto-typed. Depending
         on the driver, the discovered MIME type may be

           * application/postscript or
           * application/vnd.cups-postscript

"application/postscript" goes first thru the "pstops" filter
    (where also the page counting and accounting takes place
    currently), and the outcome will be of MIME type
    "application/vnd.cups-postscript". The pstopsfilter reads and
    uses information from the PPD and inserts user-provided options
    into the PostScript file. As a consequence, the filtered file
    will possibly have the PJL header you don't want.

"application/postscript" will be all files with a ".ps", ".ai",
    ".eps" suffix or which have as their first character string one
    of "%!" or "<04>%".

"application/vnd.cups-postscript" will be those files which do both,
    first...
    ...carry a string "LANGUAGE=POSTSCRIPT" (or similar variations
       with different capitalization) amongst the first 512 bytes,
       *plus*...
    ...contain the "PJL super escape code" amongst the first 128
       bytes ("<1B>%-12345X"). Very likely, most PostScript files
       generated on Windows using a CUPS- or other PPD, will have
       to be auto-typed as "vnd.cups-postscript".
    Probably a file produced with a "Generic PostScript driver"
    will be just "application/postscript" (have not checked).

Once the file is in "application/vnd.cups-postscript" format,
either "pstoraster" or "cupsomatic" will take over (depending
on the printer configuration, as determined by the PPD in use).

NOTE:  a printer queue with *no* PPD associated to it is a "raw"
-----  printer and all files will go directly there as received
        by the spooler; the exeption are file types
"application/octet-stream" which need the mentioned "passthrough
feature" enabled. "Raw" queues don't do any filtering at all, they
hand the file directly to the CUPS backend. This backend is
responsible for the sending of the data to the device (as visible
in the "device URI" notation as lpd://, socket://, smb://, ipp://,
http://, parallel:/, serial:/, usb:/ etc.)

NOTE,  please, also the following fact: "cupsomatic"/Foomatic are
-----  *not* native CUPS drivers and they don't ship with CUPS.
        They are a Third Party add-on, developed at Linuxprinting.org.
As such, they are a brilliant hack to make all models (driven by
Ghostscript drivers/filters in traditional spoolers) also work via
CUPS, with the same (good or bad!) quality as in these other
spoolers. "cupsomatic" is only a vehicle to execute a ghostscript
commandline at that stage in the CUPS filtering chain,  where
"normally" the native CUPS "pstoraster" filter would kick in.
cupsomatic by-passes pstoraster, "kidnaps" the printfile from CUPS
away and re-directs it to go through Ghostscipt. CUPS accepts this,
because the associated CUPS-O-Matic-/Foomatic-PPD carries a line
reading

   *cupsFilter:  "application/vnd.cups-postscript 0 cupsomatic"

This line persuades CUPS to hand the file to cupsomatic, once it
has successfully converted it to the MIME type
"application/vnd.cups-postscript". This conversion will not
happen for Jobs arriving from Windows which are autotyped
"application/octet-stream", with the according changes in
"/etc/cups/mime.types" in place.

See small drawings at the end...

I am not a programmer, so please correct me if I am wrong.

 > With traditional lpr, you can just add "-oraw" to the "print command"
 > line in smb.conf.  With cups, you don't have that alternative.

You *do* have it, I think.

But you need to disable the settings "printing = cups" and "printcap =
= cups" and use "printing = bsd" and "printcap = /etc/printcap"
instead. [Additionally, you will probably have to enable and configure
the CUPS mini-LPD daemon ("cups-lpd") run from inetd... but I have not
checked, so take this item with a grain of salt and a proper dose of
caution, please.]

 > The result is that to support both unix printing and native-driver
 > Windows printing from CUPS, you have to have two logical printers per
 > physical printer: one ("cooked") for Unix clients and one ("raw") for
 > Samba to use.

Yes, that is one current workaround, if you don't want the auto-typing
of CUPS influencing Samba/Windows client PostScript jobs.

CUPS is widely configurable and flexible, even regarding its filtering
mechanism. Another workaround in some situations would be to have
lines in "/etc/cups/mime.types" saying

   application/postscript           application/vnd.cups-raw  0  -
   application/vnd.cups-postscript  application/vnd.cups-raw  0  -

This would prevent all Postscript files to be filtered (or rather, they
will go thru the virtual "nullfilter" denoted with "-". (This could only
be useful for PS printers, or if you want to print PS code on non-PS
printers   ;-)

A single line of

   */*           application/vnd.cups-raw  0  -

would effectively send *all* files towards the backend immediately
(good luck!)

Last, you could have the following (without the need for a Samba
patch):

   application/vnd.cups-postscript  application/vnd.cups-raw  0  my_PJL_stripping_filter

You'd need to write a "my_PJL_stripping_filter" (could be a shellscript)
which parses the PostScript and removes the undesired PJL. This would
need to conform to CUPS filter design (mainly, receive and pass the
parameters printername, job-id, username, jobtitle, copies, printoptions
and possibly the filename). It would just go as world executably into
"/usr/lib/cups/filters/" and work from there, called by cups if it
encounters a MIME type "application/vnd.cups-postscript"

 > The attached patch allows you to specify an option string for cups
 > printers in smb.conf.

I think your patch is in any case very useful (if it works as
advertised  ;-).  It is the most generic, simple and flexible
approach to complement CUPS.

 > So, if you want to use native Windows drivers,
 > all you need is
 >
 >         cups printer options = raw
 >
 > in smb.conf.  You can add any other options that cups and the printer
 > understand.

Now this last sentence makes me very curious. Do you mean you can add
*multiple* options to this directive? Which syntax would be required
for this ?  (Some CUPS options are specified by an "-o option=value"
pair on the commandline, some are single values, like the "-o raw"
one...)

I am thinking on one specific usage now:

-----------------------------------------------------------------------
-> passing any available IPP job attribute to the printer / the spooler
-----------------------------------------------------------------------

For example, CUPS can handle "-o job-hold-until=indefinite". This
keeps the job in the queue "on hold". It will only be printed upon
manual release by the printer operator. This is a requirement in
many "central reproduction departments", where a few operators
manage the jobs of hundreds of users on some big machine, where no
user is allowed to have direct access. (The operators often need to
load the proper paper type before running the 10.000 page job
requested by marketing for the mailing, etc.).

A lot more useful applications come to mind, if I could pass
"any other options that cups and the printer understand" via
the smb.conf directive!!

Thanks a lot!

Cheers,
Kurt

P.S.: List, please give me some feedback, if you think this type of
       explanation could be useful in the Samba HOWTO Collection. In
       that case, I'll try to write it up in a nicer form.


#########################################################################
#
# CUPS in and of itself has this (general) filter chain (CAPITAL
# letters are FILE-FORMATS or MIME types, other are filters (this is
# true for pre-1.1.15 of pre-4.3 versions of CUPS and ESP PrintPro):
#
# <SOMETHNG>-FILEFORMAT
#      |
#      |
#      V
#     <something>tops
#      |
#      |
#      V
# APPLICATION/POSTSCRIPT
#      |
#      |
#      V
#     pstops
#      |
#      |
#      V
# APPLICATION/VND.CUPS-POSTSCRIPT
#      |
#      |
#      V
#     pstoraster   # as shipped with CUPS, independent from any Ghostscipt
#      |           # installation on the system
#      |  (= "postscipt interpreter")
#      |
#      V
# APPLICATION/VND.CUPS-RASTER
#      |
#      |
#      V
#     rasterto<something>  (f.e. Gimp-Print filters may be plugged in here)
#      |   (= "raster driver")
#      |
#      V
# SOMETHING-DEVICE-SPECIFIC
#      |
#      |
#      V
#     backend
#
#
# ESP PrintPro has some enhanced "rasterto<something>" filters as compared to
# CUPS, and also a somewhat improved "pstoraster" filter.
#
# NOTE: Gimp-Print and some other 3rd-Party-Filters (like TurboPrint) to
#       CUPS and ESP PrintPro plug-in where rasterto<something> is noted.
#
#
#########################################################################
#
# This is how "cupsomatic" comes into play:
# =========================================
#
# <SOMETHNG>-FILEFORMAT
#      |
#      |
#      V
#    <something>tops
#      |
#      |
#      V
# APPLICATION/POSTSCRIPT
#      |
#      |
#      V
#    pstops
#      |
#      |
#      V
# APPLICATION/VND.CUPS-POSTSCRIPT ----------------+
#      |                                          |
#      |                                          V
#      V                                         cupsomatic
#    pstoraster                                  (constructs complicated
#      |  (= "postscipt interpreter")            Ghostscript commandline
#      |                                         to let the file be
#      V                                         processed by a
# APPLICATION/VND.CUPS-RASTER                    "-sDEVICE=<s.th.>"
#      |                                         call...)
#      |                                          |
#      V                                          |
#    rasterto<something>                          V
#      |    (= "raster driver")     +-------------------------+
#      |                            | Ghostscript at work.... |
#      V                            |                         |
# SOMETHING-DEVICE-SPECIFIC         *-------------------------+
#      |                                          |
#      |                                          |
#      V                                          |
#    backend <------------------------------------+
#      |
#      |
#      V
#    THE PRINTER
#
#
#
# Note, that cupsomatic "kidnaps" the printfile after the
# "APPLICATION/VND.CUPS-POSTSCRPT" stage and deviates it through
# the CUPS-external, systemwide Ghostscript installation, bypassing the
# "pstoraster" filter (therefor also bypassing the CUPS-raster-drivers
# "rasterto<something>", and hands the rasterized file directly to the CUPS
# backend...
#
# cupsomatic is not made by the CUPS developers. It is an independent
# contribution to printing development, made by people from
# Linuxprinting.org. (see also http://www.cups.org/cups-help.html)
#
# NOTE: Gimp-Print and some other 3rd-Party-Filters (like TurboPrint) to
#       CUPS and ESP PrintPro plug-in where rasterto<something> is noted.
#
#
#########################################################################
#
# And this is how it works for ESP PrintPro from 4.3:
# ===================================================
#
# <SOMETHNG>-FILEFORMAT
#      |
#      |
#      V
#     <something>tops
#      |
#      |
#      V
# APPLICATION/POSTSCRIPT
#      |
#      |
#      V
#     pstops
#      |
#      |
#      V
# APPLICATION/VND.CUPS-POSTSCRIPT
#      |
#      |
#      V
#     gsrip
#      |  (= "postscipt interpreter")
#      |
#      V
# APPLICATION/VND.CUPS-RASTER
#      |
#      |
#      V
#     rasterto<something>  (f.e. Gimp-Print filters may be plugged in here)
#      |   (= "raster driver")
#      |
#      V
# SOMETHING-DEVICE-SPECIFIC
#      |
#      |
#      V
#     backend
#
# NOTE: Gimp-Print and some other 3rd-Party-Filters (like TurboPrint) to
#       CUPS and ESP PrintPro plug-in where rasterto<something> is noted.
#
#
#########################################################################
#
# This is how "cupsomatic" would come into play with ESP PrintPro:
# ================================================================
#
#
# <SOMETHNG>-FILEFORMAT
#      |
#      |
#      V
#    <something>tops
#      |
#      |
#      V
# APPLICATION/POSTSCRIPT
#      |
#      |
#      V
#    pstops
#      |
#      |
#      V
# APPLICATION/VND.CUPS-POSTSCRIPT ----------------+
#      |                                          |
#      |                                          V
#      V                                         cupsomatic
#    gsrip                                       (constructs complicated
#      |  (= "postscipt interpreter")            Ghostscript commandline
#      |                                         to let the file be
#      V                                         processed by a
# APPLICATION/VND.CUPS-RASTER                    "-sDEVICE=<s.th.>"
#      |                                         call...)
#      |                                          |
#      V                                          |
#    rasterto<something>                          V
#      |   (= "raster driver")      +-------------------------+
#      |                            | Ghostscript at work.... |
#      V                            |                         |
# SOMETHING-DEVICE-SPECIFIC         *-------------------------+
#      |                                          |
#      |                                          |
#      V                                          |
#    backend <------------------------------------+
#      |
#      |
#      V
#    THE PRINTER
#
# NOTE: Gimp-Print and some other 3rd-Party-Filters (like TurboPrint) to
#       CUPS and ESP PrintPro plug-in where rasterto<something> is noted.
#
#########################################################################
#
# And this is how it works for CUPS from 1.1.15:
# ==============================================
#
# <SOMETHNG>-FILEFORMAT
#      |
#      |
#      V
#     <something>tops
#      |
#      |
#      V
# APPLICATION/POSTSCRIPT
#      |
#      |
#      V
#     pstops
#      |
#      |
#      V
# APPLICATION/VND.CUPS-POSTSCRIPT-----+
#                                     |
#                  +------------------v------------------------------+
#                  | Ghostscript                                     |
#                  | at work...                                      |
#                  | (with                                           |
#                  | "-sDEVICE=cups")                                |
#                  |                                                 |
#                  |         (= "postscipt interpreter")             |
#                  |                                                 |
#                  +------------------v------------------------------+
#                                     |
#                                     |
# APPLICATION/VND.CUPS-RASTER <-------+
#      |
#      |
#      V
#     rasterto<something>
#      |   (= "raster driver")
#      |
#      V
# SOMETHING-DEVICE-SPECIFIC
#      |
#      |
#      V
#     backend
#
#
# NOTE: since version 1.1.15 CUPS "outsourced" the pstoraster process to
#       Ghostscript. GNU Ghostscript needs to be patched to handle the
#       CUPS requirement; ESP Ghostscript has this builtin. In any case,
#       "gs -h" needs to show up a "cups" device. pstoraster is now a
#       calling an appropriate "gs -sDEVICE=cups..." commandline to do
#       the job. It will output "application/vnd.cup-raster", which will
#       be finally processed by a CUPS raster driver "rasterto<something>"
#       Note the difference to "cupsomatic", which will *not* output
#       CUPS-raster, but a final version of the printfile, ready to be
#       sent to the printer. cupsomatic also doesn't use the "cups"
#       devicemode in Ghostscript, but one of the classical devicemodes....
#
# NOTE: Gimp-Print and some other 3rd-Party-Filters (like TurboPrint) to
#       CUPS and ESP PrintPro plug-in where rasterto<something> is noted.
#
#########################################################################
#
# And this is how it works for CUPS from 1.1.15, with cupsomatic included:
# ========================================================================
#
# <SOMETHNG>-FILEFORMAT
#      |
#      |
#      V
#     <something>tops
#      |
#      |
#      V
# APPLICATION/POSTSCRIPT
#      |
#      |
#      V
#     pstops
#      |
#      |
#      V
# APPLICATION/VND.CUPS-POSTSCRIPT-----+
#                                     |
#                  +------------------v------------------------------+
#                  | Ghostscript        . Ghostscript at work....    |
#                  | at work...         . (with "-sDEVICE=           |
#                  | (with              .            <s.th.>"        |
#                  | "-sDEVICE=cups")   .                            |
#                  |                    .                            |
#                  | (CUPS standard)    .      (cupsomatic)          |
#                  |                    .                            |
#                  |          (= "postscript interpreter")           |
#                  |                    .                            |
#                  +------------------v--------------v---------------+
#                                     |              |
#                                     |              |
# APPLICATION/VND.CUPS-RASTER <-------+              |
#      |                                             |
#      |                                             |
#      V                                             |
#     rasterto<something>                            |
#      |   (= "raster driver")                       |
#      |                                             |
#      V                                             |
# SOMETHING-DEVICE-SPECIFIC <------------------------+
#      |
#      |
#      V
#     backend
#
#
# NOTE: Gimp-Print and some other 3rd-Party-Filters (like TurboPrint) to
#       CUPS and ESP PrintPro plug-in where rasterto<something> is noted.
#
##########################################################################

I hope this helps more people understand how CUPS works and how they
can possibly tweak it to their needs.


==============================================================================
<<< EXTANT 2 >>>
==============================================================================
Subject: Print Drivers and Devices with CUPS
============================================

CUPS ships a well-working Laserjet driver. Install it (as root) with

    "lpadmin -p laserjet4plus -v parallel:/dev/lp0 -E -m laserjet.ppd"

(The "-m" switch will retrieve the "laserjet.ppd" from the standard repository
for not-yet-installed-PPDs, which CUPS keeps at "/usr/share/cups/model/". Alter-
natively, you may use "-P /absolute/filesystem/path/to/where/there/is/PPD/your.ppd")

You didn't state if the print system is working on the Linux side of things.
Even if it does -- to print from Windows, involves some more steps....

But let me first point out some more general things about printer "drivers"
for Linux/Unix (yes, and for Mac OS X now!), be it you use CUPS or one of
the venerable (I'd even call them "ancient" and "rusty" now...) printing
systems.

You  -- and everybody else, for that matter --  should always also consult the
database on linuxprinting.org for all recommendations about "which driver
is best used for which printer":

   http://www.linuxprinting.org/printer_list.cgi

There select your model and click on "Show". You'll arrive at a page listing
all drivers working with your model. There will always be *one* "recommended"
one. Try this one first. In your case ("HP LaserJet 4 Plus"), you'll arrive
here:

   http://www.linuxprinting.org/show_printer.cgi?recnum=75104

The recommended driver is "ljet4". It has a link to the page for the ljet4
driver too:

   http://www.linuxprinting.org/show_driver.cgi?driver=ljet4

On the driver's page, you'll find various important and detailed infos about
how to use that driver within various spoolers. You can generate a PPD for
CUPS. The PPD contains all the info about how to use your model and the driver;
this is, once installed, working transparently for the user -- you'll only
need to choose resolution, paper size etc. from the web-based menu or from
the print dialog GUI or from the commandline...

On the driver's page, choose to use the "PPD-O-Matic" online PPD generator
program. Select your model and click "Generate PPD file". When you safe the
appearing ASCII text file, don't use "cut'n'past" (as it will possible corrupt
line endings and tabs), but use "Save as..." in your browser's menu. Save it
at "/some/path/on/your/filesystem/somewhere/my-name-for-my-printer.ppd"

Then install the printer:

    "lpadmin -p laserjet4plus -v parallel:/dev/lp0 -E -P /some/path/on/your/filesystem/somewhere/my-name-for-my-printer.ppd"

Note, that for all the "Foomatic-PPDs" from Linuxprinting.org, you also need
a special "CUPS filter" named "cupsomatic". Get the latest version of
"cupsomatic" from

     http://www.linuxprinting.org/cupsomatic

This needs to be copied to "/usr/lib/cups/filter/cupsomatic" and be made world
executable. This filter is needed to read and act upon the specially encoded
Foomatic comments, embedded in the printfile, which in turn are used to
construct (transparently for you, the user) the complicated ghostscript command
line needed for your printer/driver combo.

You can have a look at all the options for the Ghostscript commandline supported
by your printer and the ljet4 driver by going to the section "Execution details",
selecting your model (Laserjet 4 Plus) and clicking on "Show execution details".
This will bring up this web page:

    http://www.linuxprinting.org/execution.cgi?driver=ljet4&printer=75104&.submit=Show+execution+details

The ingenious thing is this: the database is kept very current. If there
is a bug fix and an improvement somewhere in the database, you will
always get the most current and stable and feature-rich driver by following
the steps described above... Till Kamppeter from MandrakeSoft is doing an
excellent job here, and too few people still know about it. (So if you use
it often, please send him a note of your appreciation sometime...)

(The latest and greatest improvement now is support for "custom page sizes"
for all those printers which support it...)

"cupsomatic" is documented here:

    http://www.linuxprinting.org/cups-doc.html

More printing tutorial info may be found here:

    http://www.linuxprinting.org/kpfeifle/LinuxKongress2002/Tutorial/

Note, that *all* the Foomatic drivers listed on Linuxprinting.org (now
approaching the "all-time high" number of 1.000 for the supported models)
are using a special filtering chain involving Ghostscript, as described
in great detail in the Samba CVS sources (for 2.2.x) in

    docs/textdocs/CUPS-PrintingInfo.txt

To sum it up:

* having a "foomatic+<something>" PPD is not enough to print with CUPS
   (but it is *one* important component)
* you also need the "cupsomatic" filter script (Perl) in "/usr/lib/cups/filters/"
* you need Perl to make cupsomatic run
* you also need Ghostscript (because it is called and controlled by the
   PPD/cupsomatic combo in a way to fit your printermodel/driver combo...)
* your Ghostscript *must*, depending on the driver/model, contain support
   for a certain "device" (as shown by "gs -h")

In the case of the "hpijs" driver, you need a Ghostscript version, which
is showing a "ijs" amongst its supported devices in "gs -h". In the case of
"hpijs+foomatic", a valid ghostscript commandline would be reading like this:

       gs -q -dBATCH -dPARANOIDSAFER -dQUIET -dNOPAUSE -sDEVICE=ijs       \
             -sIjsServer=hpijs<PageSize> -dDuplex=<Duplex> <Model>        \
             -r<Resolution>,PS:MediaPosition=<InputSlot> -dIjsUseOutputFD \
             -sOutputFile=- -

Note, that with CUPS and the "hpijs+foomatic" PPD (plus Perl and cupsomatic)
you don't need to remember this. You can choose the available print options
thru a GUI print command (like "glp" from ESP's commercially supported
PrintPro software, or KDE's "kprinter", or GNOME's "gtklp" or the independent
"xpp") or the CUPS web interface via human-readable drop-down selection
menus.....

If you use "ESP Ghostscript" (also under the GPL, provided by Easy Software
Products, the makers of CUPS, downloadable from http://www.cups.org/software.html,
co-maintained by the developers of linuxprinting.org), you are guaranteed to
have in use the most uptodate, bug-fixed, enhanced and stable version of a Free
Ghostscript. It contains support for ~300 devices, whereas plain vanilla
GNU Ghostscript 7.05 only has ~200....

>>/ However, I can only print a Cups test page, from the web interface. when I
/>>/ try to print a windows test page, it acts like the job was never sent.
/
  * Can you print "standard" jobs from the CUPS machine?

  * Are the jobs from Windows visible in the Web interface on CUPS
    (http://localhost:631/)?

*Most important:* What kind of printer driver are you using on the Windows clients???

You can try to get a more detailed debugging info by setting "LogLevel debug" in
"/etc/cups/cupsd.conf", re-start cupsd and investigate "/var/log/cups/error_log"
for the whereabouts of your Windows-originating printjobs:

   * what does the "auto-typing" line say? which is the "MIME type" CUPS thinks
     is arriving from the Windows clients?
   * are there "filter" available for this MIME type?
   * are there "filter rules" defined in "/etc/cups/mime.convs" for this MIME type?

==============================================================================
<<< EXTANT 3 >>>
==============================================================================
Subject: Printer Drivers
========================

>> Where can I find a program or how can I configure my samba server in order
>> to limit the number of pages to be printed by users.

The feature you want is dependent on the real print subsystem
you're using. Samba's part is always to receive the job files
from the clients (filtered *or* unfiltered) and hand it over
to this printing subsystem.

Of course one could "hack" things with one's own scripts.

But there is CUPS (Common Unix Printing System). CUPS supports "quotas".
Quotas can be based on sizes of jobs or on the number of pages or both,
and are spanning any time period you want.

This is an example command how root would set a print quota in CUPS,
assuming an existing printer named "quotaprinter":

  lpadmin -p quotaprinter -o job-quota-period=604800 -o job-k-limit=1024 -o job-page-limit=100

This would limit every single user to print 100 pages or 1024 KB of
data (whichever comes first) within the last 604.800 seconds ( = 1 week).

For CUPS to count correctly, the printfile needs to pass the CUPS
"pstops" filter, otherwise it uses a "dummy" count of "1". (Some
printfiles don't pass it -- f.e. image files -- but then those are
mostly 1 page jobs anyway). This also means, proprietary drivers for
the target printer running on the client computers and CUPS/Samba
then spooling these files as "raw" (i.e. leaving them untouched, not
filtering them), will be counted as "1-pagers" too!

You need to send PostScript from the clients (i.e. run a PostScript
driver there) for having the chance to get accounting done. If the
printer is a non-PostScript model, you need to let CUPS do the job to
convert the file to a print-ready format for the target printer. This
will be working for currently ~1.000 different printer models, see

     http://www.linuxprinting.org/printer_list.cgi

Before CUPS-1.1.16 your only option was to use the Adobe PostScript
Driver on the Windows clients. The output of this driver was not always
passed thru the "pstops" filter on the CUPS/Samba side, and therefor was
not counted correctly (the reason is that it often --- depending on the
"PPD" being used --- did write a "PJL"-header in front of the real
PostScript which made CUPS to skip the pstops and go directy to
the "pstoraster" stage).

 From CUPS-1.1.16 onward you can use the "CUPS PostScript Driver
for Windows NT/2K/XP clients" (it is tagged in the download area of
http://www.cups.org/ as the "cups-samba-1.1.16.tar.gz" package).
It is *not* working for Win9x/ME clients. But it....

   ...it guarantees to not write an PJL-header;
   ...it guarantees to still read and support all PJL-options named
      in the driver PPD with its own means;
   ...it guarantees the file going thru the "pstops" filter on the
      CUPS/Samba server;
   ...it guarantees to page-count correctly the printfile...

You can read more about the setup of this combination in the
manpage for "cupsaddsmb" (only present with CUPS installed, only
current with CUPS 1.1.16).

These are the items CUPS logs in the "page_log" for every single
*page* of a job:

* Printer name
* User name
* Job ID
* Time of printing
* the page number
* the number of copies
* a billing info string (optional)

Here is an extract of my CUPS server's page_log file to illustrate
the format and included items:

infotec_IS2027 kurt 40 [22/Nov/2002:13:18:03 +0100] 1 2  #marketing
infotec_IS2027 kurt 40 [22/Nov/2002:13:18:03 +0100] 2 2  #marketing
infotec_IS2027 kurt 40 [22/Nov/2002:13:18:03 +0100] 3 2  #marketing
infotec_IS2027 kurt 40 [22/Nov/2002:13:18:03 +0100] 4 2  #marketing
infotec_IS2027 kurt 40 [22/Nov/2002:13:18:03 +0100] 5 2  #marketing
infotec_IS2027 kurt 40 [22/Nov/2002:13:18:03 +0100] 6 2  #marketing

This was Job ID "40", printed on "infotec_IS2027" by user "kurt",
a 6-page job printed in 2 copies and billed to "#marketing"...

Which flaws or shortcomings are there?

  * the ones named above;
  * CUPS really counts the job pages being *processsed in software*
    (going thru the "RIP") rather than the physical sheets successfully
    leaving the printing device -- if there is a jam while printing
    the 5th sheet out of 1000 and the job is aborted by the printer,
    the "page count" will still show the figure of 1000 for that
    job;
  * all quotas are the same for all users (no flexibility to
    give the boss a higher quota than the clerk)
  * no support for groups;
  * no means to read out the current balance or "used-up"
    number of current quota;
  * a user having used up 99 sheets of 100 quota will still be
    able to send and print a 1.000 sheet job;
  * a user being denied a job because of a filled-up quota
    doesn't get a meaningful error message from CUPS other than
    "client-error-not-possible".

But this is the best system out there currently. And there are
huge improvements under development:

--> page counting will go into the "backends" (these talk directly
     to the printer and will increase the count in sync with the
     actual printing process  -- a jam at the 5th sheet will lead
     to a stop in the counting...)

--> quotas will be handled more flexibly;

--> probably there will be support for users to inquire their
     "accounts" in advance;

--> probably there will be support for some other tools around
     this topic...

Other than the current stage of the CUPS development, I don't
know any other ready-to-use tool which you could consider.


==============================================================================
<<< EXTANT 4 >>>
==============================================================================
Subject: More on CUPS Print Drivers
===================================

>> If you could get around the EULA, then you could package preinitialized 
>> drivers and write the information to smbd's tdbs.  We have support for 
>> storing driver initialization data already.
> 
> Have you heard that you can get CUPS printer drivers exactly for that
> from cups.org? If they are good drivers, this could be very interesting.

Hi, all,

I'll give you some more info about the PostScript driver Volker mentioned
above here as a reference. (Maybe one day before the 3.0 release it will
end up as a worked-out paragraph inside the HOWTO collection):

You can download the driver files from http://www.cups.org/software.html. It
is a separate package from the CUPS base software files, tagged as "CUPS 1.1.16
Windows NT/2k/XP Printer Driver for SAMBA (tar.gz, 192k)". The filename to
download is "cups-samba-1.1.16.tar.gz". Upon untar-/unzip-ping it will reveal
the files

   cups-samba.install
   cups-samba.license
   cups-samba.readme
   cups-samba.remove
   cups-samba.ss

These have been packaged with the ESP meta packager software "EPM". The
*.install and *.remove files are simple shell script, which untars the
*.ss (which is nothing else than a tar-archive) and puts its contents
into "/usr/share/cups/drivers/". Its contents are 3 files:

   cupsdrvr.dll
   cupsui.dll
   cups.hlp

[ ATTENTION: due to a bug the current release puts the "cups.hlp" into
   "/usr/share/drivers/" instead of "/usr/share/cups/drivers/". To work
   around this, copy/move the file after running the "./cups-samba.install"
   script manually to the right place:

      "cp /usr/share/drivers/cups.hlp /usr/share/cups/drivers/" ]

This new CUPS PostScript driver is currently binary-only, but free (as in
free beer); no source code is provided (yet). The reason is this: it has
been developed with the help of the Microsoft Driver Developer Kit (DDK)
and compiled with Microsoft Visual Studio 6. It is not clear to the driver
developers if they are allowed to distribute the whole of the source code
as Free Software. However, they will likely release the "diff" in source
code under the GPL, so anybody with a license of Visual Studio and a DDK
will be able to compile for him/herself.

Once you have run the install script (and possibly manually moved the
"cups.hlp" file to "/usr/share/cups/drivers/"), the driver is ready to be
put into Samba's [print$] share (which often maps to "/etc/samba/drivers/"
and contains a subdir tree with WIN40 and W32X86 branches), by running
"cupsaddsmb" (see also "man cupsaddsmb" for CUPS 1.1.16). [Don't forget to
put root into the smbpasswd file by running "smbpasswd" should you run
this whole procedure for the first time.] Once the driver files are in the
[print$] share, they are ready to be downloaded and installed by the
Win NT/2k/XP clients.

NOTE 1: Win 9x/ME clients won't work with this driver. For these you'd
         still need to use the ADOBE*.* drivers as previously.

NOTE 2: It is not harming if you've still the ADOBE*.* driver files from
         previous installations in the "/usr/share/cups/drivers/" directory.
         The new cupsaddsmb (from 1.1.16) will automatically use the
         "newest" installed driver (which here then is the CUPS drivers).

NOTE 3: Should your Win clients have had the old ADOBE*.* files and the
         Adobe PostScript drivers installed, the download and installation
         of the new CUPS PostScript driver for Windows NT/2k/XP will fail
         at first.
         It is not enough to "delete" the printer (as the driver files
         will still be kept by the clients and re-used if you try to
         re-install the printer). To really get rid of the Adobe driver
         files on the clients, open the "Printers" folder (possibly via
         "Start --> Settings --> Control Panel --> Printers"), right-click
         onto the folder background and select "Server Properties". A
         new dialog opens; select the "Drivers" tab; on the list select
         the driver you want to delete and click on the "Delete" button.
         (This will only work if there is no single printer left which
         uses that particular driver -- you need to "delete" all printers
         using this driver in the "Printers" folder first...)

NOTE 4: Once you have successfully downloaded the CUPS PostScript driver
         to a client, you can easily switch all printers to this one
         by proceeding as described elsewhere in the "Samba HOWTO
         Collection" to change a driver for an existing printer....


What are the benefits with the "CUPS PostScript driver for Windows NT/2k/XP"
as compared to the Adobe drivers?

* no hassle with the Adobe EULA; no hassle with the question "where do I
   get the ADOBE*.* driver files from?"

* the Adobe drivers (depending on the printer PPD associated with them)
   often put a PJL header in front of the core PostScript part of the print
   file (thus the file starts with "<1B>%-12345X" or "<escape>%-12345X"
   instead of "%!PS"). This leads to the CUPS daemon autotyping the
   arriving file as a print-ready file, not requiring a pass thru the
   "pstops" filter (to speak more technical, it is not regarded as the
   generic MIME type "application/postscript", but as the more special
   MIME type "application/cups.vnd-postscript"), which therefore also
   leads to the page accounting in "/var/log/cups/page_log" not receiving
   the exact mumber of pages; instead the dummy page number of "1" is
   logged in a standard setup...)

* the Adobe driver has more options to "mis-configure" the PostScript
   generated by it (like setting it inadvertedly to "Optimize for Speed",
   instead of "Optimize for Portability", which could lead to CUPS being
   unable to process it....)

* the CUPS PostScript driver output sent by Windows clients to the CUPS
   server will be guaranteed to be auto-typed as generic MIME type
   "application/postscript", thusly passing thru the CUPS "pstops" filter
   and logging the correct number of pages in the page_log for accounting
   and quota purposes...

* the CUPS PostScript driver supports the sending of additional print
   options by the Win NT/2k/XP clients, such as naming the CUPS standard
   banner pages (or the custom ones, should they be installed at the time
   of driver download), using the CUPS "page-label" option, setting a
   job-priority and setting the scheduled time of printing (with the option
   to support additional useful IPP job attributes in the future).

* the CUPS PostScript driver supports the inclusion of the new
   "*cupsJobTicket" comments at the beginnig of the PostScript file (which
   could be used in the future for all sort of beneficial extensions on
   the CUPS side, but which will not disturb any other application as those
   will regard it as a comment and simply ignore it).

* the CUPS PostScript driver will be the heart of the fully fledged CUPS
   IPP client for Windows NT/2k/XP to be released soon (probably alongside
   the first Beta release for CUPS 1.2).

==============================================================================
<<< EXTANT 5 >>>
==============================================================================
Subject: Printing with Bells and Whistles
=========================================

May I suggest a radically different approach to your problem?

* Let the Windows Clients use a PostScript driver, to produce
   PostScript as their print output sent towards the Samba print
   server (just like any Linux or Unix Client would also use
   PostScript to send to the server...)

* make the Unix printing subsystem which is underneath Samba
   convert the incoming PostScript files to the native print
   format of the target printers (would likely be PCL?
   I understand you have mainly HP models?)

* You're afraid, that this would just mean a *Generic* PostScript
   driver for the clients? With no Simplex/Duplex selection,
   no paper tray choice? But you need them to be able to set up
   their jobs, ringing all the bells and whistles of the printers?

   --> Not possible with traditional spooling systems!

   --> But perfectly supported by CUPS (which uses "PPD" files to
       describe how to control the print options for PostScript and
       non-PostScript devices alike...

   CUPS PPDs are working perfectly on Windows
   clients who use Adobe PostScript drivers (or the new CUPS
   PostScript driver for Windows NT/2K/XP). Clients can use
   them to setup the job to their liking and CUPS will use
   the received job options to make the (PCL-, ESC/P- or
   PostScript-) printer behave as required.

* You want to have the additional benefit of page count logging
   and accounting? In this case the CUPS PostScript driver
   is the best choice (better than the Adobe one).

* You want to make the drivers downloadable for the clients?
   "cupsaddsmb" is your friend. It will setup the [print$]
   share on the Samba host to be ready to serve the clients
   for a "point and print" driver installation...

"What strings are attached?", I hear you asking...

You are right, there are some. But, given the sheer CPU power
you can buy nowadays in German supermarkets, these can be
overcome easily.

The strings: Well, if the
CUPS/Samba side will have to print a *lot* onto 40 printers
serving 500 users, you probably will need to set up a second
server (which can do automatic load balancing with the first
one, plus a degree of fail-over mechanism). Converting the
incoming PostScript jobs, "interpreting" them for
non-PostScript printers, amounts to the work of a "RIP"
(Raster Image Processor) done in software. This requires
more CPU and RAM than for the mere "raw spooling" task
your current setup is solving... It all depends on the
avarage and peak printing load the server should be
able to handle....

==============================================================================
<<< EXTANT 6 >>>
==============================================================================
Subject: Deletion of CUPS spool files
=====================================

From samba-technical-admin@lists.samba.org  Thu Dec  5 17:18:48 2002
Zdenek Niederle wrote on Samba-digest:

> Message: 1
> From: Zdenek Niederle <zniederle@collicutt.com>
> Organization: Collicutt Hanover
> To: samba-technical@lists.samba.org
> Subject: Clean up of spool files
> Date: Wed, 4 Dec 2002 15:13:15 -0700
> 
> I'm using Samba 2.2.5 and CUPS to handle printing on our network.  
> Unfortunately, the smbprn.xxxxxx spool files are not being cleaned up and 
> instead are quickly filling the spool directory.  Is their a setting or 
> option to ensure the files are cleaned up once sent to the printer?  I am 
> aware that using a cron job would work but this can't be the best solution.
> 
> Thanks.


Hi, Zdenek,

you need to be aware, that the Samba print files pass thru 2
different "spool" directories. Once the incoming directory
managed by Samba, (set f.e. in the "path = /var/spool/samba"
directive in the [printers] section of "smb.conf"). Second is
the spool directory of your UNIX print subsystem. For CUPS it is
normally "/var/spool/cups/", as set by the cupsd.conf directive
"RequestRoot /var/spool/cups".

I am not sure, which one of your directories keeps the files.
 From what you say, it is most likely the Samba part.

For the CUPS part, you may want to consult:

   http://localhost:631/sam.html#PreserveJobFiles and
   http://localhost:631/sam.html#PreserveJobHistory and
   http://localhost:631/sam.html#MaxJobs

There are the settings described for your CUPS daemon, which
could lead to completed job files not being deleted.

"PreserveJobHistory Yes" -- keeps some details of jobs in
cupsd's mind (well it keeps the "c12345", "c12346" etc. files
in the CUPS spool directory, which do a similar job as the
old-fashioned BSD-LPD control files). This is set to "Yes"
as a default.

"PreserveJobFiles Yes" -- keeps the job files themselves in
cupsd's mind (well it keeps the "d12345", "d12346" etc. files
in the CUPS spool directory...). This is set to "No" as the
CUPS default.

"MaxJobs 500" -- this directive controls the maximum number
of jobs that are kept in memory. Once the number of jobs
reaches the limit, the oldest completed job is automatically
purged from the system to make room for the new one. If all
of the known jobs are still pending or active then the new
job will be rejected. Setting the maximum to 0 disables this
functionality. The default setting is 0.

(There are also additional settings for "MaxJobsPerUser" and
"MaxJobsPerPrinter"...)

For everything to work as announced, you need to have three
things:

   * a Samba-smbd which is compiled against "libcups" (Check
     on Linux by running "ldd `which smbd`")

   * a Samba-smb.conf setting of "printing = cups"

   * another Samba-smb.conf setting of "printcap = cups"

Note, that in this case all other manually set printing-related
commands (like "print command", "lpq command", "lprm command",
"lppause command" or "lpresume command") are ignored and they
should normally have no influence what-so-ever on your printing.

If you want to do things manually, replace the "printing = cups"
by "printing = bsd". Then your manually set commands may work
(haven't tested this), and a "print command = lp -d %P %s; rm %s"
may do what you need.

You forgot to mention the CUPS version you're using. If you did
set things up as described in the man pages, then the Samba
spool files should be deleted. Otherwise it may be a bug. On
the CUPS side, you can control the behaviour as described
above.

If you have more problems, post the output of these commands:

   grep -v ^# /etc/cups/cupsd.conf | grep -v ^$
   grep -v ^# /etc/samba/smb.conf | grep -v ^$ | grep -v "^;"

(adapt paths as needed). These commands sanitize the files
and cut out the empty lines and lines with comments, providing
the "naked settings" in a compact way.

Cheers,
Kurt

